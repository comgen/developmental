
title: "DE and molecular switches Maryland CC"
author: "Asbj√∏rn"
date: "2023/11/1"
output: html_notebook
editor_options: 
  chunk_output_type: inline
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(message = FALSE)
library(tidyverse)
#library(annotables)
library(edgeR)
library(RColorBrewer)
library(ggrepel)
library(limma)
library(magrittr)
library(biomaRt)
theme_set(theme_bw()) #change default ggplot background
theme_update(text= element_text(size = 7, family = "sans"))
#fixing default function names
select <- dplyr::select
rename <- dplyr::rename
filter <- dplyr::filter
relocate <- dplyr::relocate
colnames <- base::colnames
rownames <- base::rownames

#I have suggested using blue (#E64B35FF) and red (#8491B4FF) whenever we do a direct comprison between CC and OFC
```


This code is to import the Maryland data and produce normalised and filtered data.



### Add sample info

```{r add info}
info_OFC <- 
  readxl::read_xlsx("/Users/asbjorh/PhD/ANK3_HTS-amplicons/Maryland/data/Maryland_Samples_NBB1582DonorInfo_cleaned.xlsx", sheet = 1, col_names = TRUE) %>% 
  dplyr::select(c("RNA ID", "AGEYEARS", "AGEDAYS", "RIN AMG", "RNAseq", "PMINTERVAL", "CDEATHOFF")) %>% filter(RNAseq!=0) %>% select(-RNAseq) %>% distinct()

#simplify the names of samples to match data
info_OFC$`RNA ID` <-  str_remove(info_OFC$`RNA ID`, "MD_")
info_OFC$`RNA ID` <-  str_remove(info_OFC$`RNA ID`, "_RNA")
info_OFC$`RNA ID` <-  str_replace(info_OFC$`RNA ID`, "_", "-")
info_OFC <- dplyr::rename(info_OFC, sampleID="RNA ID")

info_OFC <- info_OFC %>% filter(!(sampleID=="5162-BA11" & `RIN AMG`== 9.6)) #this sample has 2 entries, unknown which was used for RNAseq, remove best RIN, keep RIN = 9.1

info_OFC <- dplyr::rename(info_OFC, RIN_AMG="RIN AMG")

info_OFC$sampleID <- str_remove(info_OFC$sampleID,  "-BA11")

info_CC <-
readxl::read_xlsx("~/proj_Maryland_WGCNA/data/RNAseq_CC samples_december_2021/sample_table_96_RNAseq_cleaned.xlsx", sheet = 1, col_names = TRUE)


info_CC <- 
  info_CC %>% 
  select(sampleID, RIN_AMG)

info_CC$sampleID <- as.character(info_CC$sampleID)

info_CC <- 
  info_CC %>% left_join(select(info_OFC, -RIN_AMG), by= "sampleID")


#change age (years+days) into decimal years. Remove cause of death.

info_CC <- 
  info_CC %>% 
  mutate(sampleID = paste0(sampleID, "-CC")) %>% 
  dplyr::mutate(AGE = AGEYEARS + (AGEDAYS/365)) %>%
    select(-AGEYEARS, -AGEDAYS)

info_OFC <- 
  info_OFC %>% 
  mutate(sampleID = paste0(sampleID, "-OFC")) %>% 
  select(-CDEATHOFF) %>% 
  dplyr::mutate(AGE = AGEYEARS + (AGEDAYS/365)) %>%
    select(-AGEYEARS, -AGEDAYS)

#mke a category for age. IA suggested +-12 Years, based on Kang et al (2011)'s definition of adolescence 

info_CC <-
  info_CC %>% 
  mutate(below12 = case_when(
    AGE < 12  ~ 1,
    TRUE ~ 0)
  )

info_CC$below12 <- as.factor(info_CC$below12)

#do the same for OFC
info_OFC <-
  info_OFC %>% 
  mutate(below12 = case_when(
    AGE < 12  ~ 1,
    TRUE ~ 0)
  )

info_OFC$below12 <- as.factor(info_OFC$below12)
```



```{r import counts CC}
#f = list.files("/Users/asbjorh/PhD/RNAseq_temporal/data/CC/Hughes-RNA6-2021-12-08/20_mapDataRSEM/",  pattern= ".genes.results$", full.names  = TRUE) #results from RSEM

f = list.files("/Users/asbjorh/PhD/RNAseq_temporal/data/CC/Hughes-RNA6-2021-12-08/40_countData/",  pattern= ".counts$", full.names  = TRUE) #results from 


#if RSEM results:
#dat = lapply(f, 
#             function(i){          #get the data from each sample
#  x = read_tsv(i, col_names = TRUE, skip = 0)
#  x = x[, c(1,4,5)] 
#  # add a column to say which file they're from
#  x$file = i
#  # Return your data
#  x
#}
#)

#if featurecounts results:
dat = lapply(f, 
             function(i){          #get the data from each sample
  x = read_tsv(i, col_names = FALSE, skip = 2)
  x = x[, c(1,6,7)] 
  # add a column to say which file they're from
  x$file = i
  # Return your data
  x
}
)


d<-
  do.call("rbind.data.frame", dat) #make a dataframe out of the imported datasets (combine by )


d$file <- #remove unnescessary prefix text from sample names
  str_remove(d$file, "/Users/asbjorh/PhD/RNAseq_temporal/data/CC/Hughes-RNA6-2021-12-08/40_countData//") 

d$file  <- #replace unnescessary suffix text from sample names
  str_replace(d$file , ".counts", "-CC") 


d <- 
  pivot_wider(dplyr::select(d, -X6), names_from= file, values_from = X7 ) 

 count <- d %>% column_to_rownames(var="X1")

 count_CC <- count


#if using RSEM data
#d$file <- #remove unnescessary prefix text from sample names
 # str_remove(d$file, "/Users/asbjorh/PhD/RNAseq_temporal/data/CC/Hughes-RNA6-2021-12-08/20_mapDataRSEM//") 

#d$file  <- #replace unnescessary suffix text from sample names
 # str_replace(d$file , "_rsemExpr.genes.results", "-CC") 

#count <- d %>% select(gene_id, file, expected_count) %>% pivot_wider(names_from = file, values_from = expected_count, id_cols = gene_id) 
#count <- count %>% column_to_rownames(var="gene_id")


```

```{r import counts OFC}
f = list.files("/Users/asbjorh/PhD/RNAseq_temporal/data/OFC/",  pattern= ".counts$", full.names  = TRUE) #results from 


#if featurecounts results:
dat = lapply(f, 
             function(i){          #get the data from each sample
  x = read_tsv(i, col_names = FALSE, skip = 2)
  x = x[, c(1,6,7)] 
  # add a column to say which file they're from
  x$file = i
  # Return your data
  x
}
)


d<-
  do.call("rbind.data.frame", dat) #make a dataframe out of the imported datasets (combine by )


d$file <- #remove unnescessary prefix text from sample names
  str_remove(d$file, "/Users/asbjorh/PhD/RNAseq_temporal/data/OFC//") 

d$file  <- #replace unnescessary suffix text from sample names
  str_replace(d$file , ".counts", "-OFC") 


d <- 
  pivot_wider(dplyr::select(d, -X6), names_from= file, values_from = X7 ) 

 count <- d %>% column_to_rownames(var="X1")

 colnames(count) <- str_remove(colnames(count),  "-BA11")
 
 count_OFC <- count

```




```{r Process data}
#clinMeta <- info_CC
clinMeta <- info_OFC

#
#count <- count_CC
count <- count_OFC

# exclude outlier CC_1259 sample
exclude <- "1259-CC"
count <- count[, !colnames(count) %in% exclude] 

SampleID <- colnames(count)[colnames(count) %in% clinMeta$sampleID] #make any other adjustments to which samples to include/ exclude here

data <- count[,colnames(count) %in% (SampleID)] #count is already in the form of a dataframe with rownames
data <- round(data) # round data since RSEM output may be non-integer

colData <- clinMeta


colData <- colData %>%  column_to_rownames(var="sampleID") #to make a dataframe with rownames
colData <- colData[colnames(data),] #order the sample names the same as the expression data
all( rownames(colData) == colnames(data))

#colData[,c(2,4,5,6)] <- lapply(colData[,c(2,4,5,6)],as.factor) #adjust any columns with factor values
#colData[,c(3,7,8)] <- lapply(colData[,c(3,7,8)],as.numeric) #similarly, make sure numerical values are properly labeled.


library(biomaRt)
ensembl <- useMart("ensembl", dataset="hsapiens_gene_ensembl", host="https://useast.ensembl.org")

genemap <- getBM(attributes=c("entrezgene_id","ensembl_gene_id", "external_gene_name", "gene_biotype", "go_id", "name_1006", "chromosome_name", "start_position", "end_position"), 
                 filters="ensembl_gene_id", 
	#values=rownames(data), 
	values=colnames(cpm_all_wide),
	mart=ensembl)
genemap <- genemap[ duplicated(genemap$ensembl_gene_id) == F,]
rownames(genemap) <- genemap$ensembl_gene_id #rownames in case dataframe is needed


## Remove lowly expressed genes

#library(edgeR)
keep <- filterByExpr(data, design=colData$below12 #we don't want to have design here, do we? Because if genes are not at all expressed in either category it will be filtered out?  -> The opposite is true! Group-aware filtering makes sure there is expression in enough samples within at least one group. 
)
data.filt <- data[keep,]


## Keep only protein-coding and lncRNA genes
genemap2 <- genemap[rownames(data.filt),]
genemap2 <- subset(genemap2, gene_biotype %in% c("protein_coding","lncRNA"))
data.filt <- data.filt[rownames(genemap2),]
```


```{r DE analyses childhood vs adolescence}
#analysis <- "CC_DE_below12"
analysis <- "OFC_DE_below12"
sig_level <- 0.01

res_dir <- paste0("~/proj_Maryland_WGCNA/analysis/", analysis)


y <- DGEList(counts = data.filt, genes = genemap2, samples=SampleID)
y <- calcNormFactors(y) #normLibSizes is the new name for calcNormFactors

design <- model.matrix(~ below12  + RIN_AMG + PMINTERVAL, data = colData)

v <- voomWithQualityWeights(y, design, plot = TRUE)
fit <- lmFit(v, design)
fit <- eBayes(fit)
summary(decideTests(fit, p.value=sig_level))

res <- topTable(fit, coef="below121", n=Inf, p.value=1)
#write.table(res, paste0(res_dir, "/de_limma_OFC_below12.txt"), sep="\t", row.names=F)


table_sign_genes <- summary(decideTests(fit, p.value=sig_level))
kableExtra::kable(table_sign_genes, "latex", caption = paste("Number of significant genes", "FDR<", sig_level)) %>% 
  kableExtra::save_kable(paste0(res_dir, "/sign.genes.png"))

write.table(res, paste0(res_dir,"_",analysis, "/de_limma.txt"), sep="\t", row.names=F)


if(identical(analysis,  "OFC_DE_below12")){
DE_0.01_OFC <- res %>% filter(adj.P.Val <= 0.01)
}  

if(identical(analysis,  "CC_DE_below12")){
  DE_genes_0.01_CC <- res %>% filter(adj.P.Val <= 0.01)
}  

```

```{r DE analyses OFC vs CC}
#analysis <- "CC_DE_below12"
#analysis <- "OFC_DE_below12"
#sig_level <- 0.05

analysis <- "OFC_CC_DE"
sig_level <- 0.01

res_dir <- paste0("~/proj_Maryland_WGCNA/analysis/", analysis, "/")

counts_all <- 
  bind_cols(count_CC, count_OFC)

counts_all <- na.omit(counts_all)

colData_all <-  bind_rows("OFC"=info_OFC,
                          "CC"= select(info_CC, -CDEATHOFF),
                          .id = "region")
 
colData_all <- colData_all %>% filter(sampleID != exclude) 

sample_all <-  colnames(counts_all)[colnames(counts_all) %in% colData_all$sampleID]

design <- model.matrix(~ region, data = colData_all)
keep <- filterByExpr(counts_all, design = design) #keep genes that have decent expression in at least one group
                     
# keep <- filterByExpr(counts_all #default is remove genes with very low in >30% of samples. Removes genes completely without expression in one of the regions. Is that what we want? 
# )
counts_all.filt <- counts_all[keep,]

genemap2 <- genemap[rownames(counts_all.filt),]
genemap2 <- subset(genemap2, gene_biotype %in% c("protein_coding","lncRNA"))

counts_all.filt <- counts_all.filt[rownames(counts_all.filt) %in% rownames(genemap2), colnames(counts_all.filt) != exclude]

y <- DGEList(counts = counts_all.filt, genes = genemap2, samples=sample_all)
y <- calcNormFactors(y) #normLibSizes is the new name for calcNormFactors

design <- model.matrix(~ region  + RIN_AMG + PMINTERVAL, data = colData_all)

v <- voomWithQualityWeights(y, design, plot = TRUE)
fit <- lmFit(v, design)
fit <- eBayes(fit)
summary(decideTests(fit, p.value=sig_level))

table_sign_genes <- summary(decideTests(fit, p.value=sig_level))

#save table with number of genes
kableExtra::kable(table_sign_genes, "latex", caption = paste("Number of significant genes", "FDR<", sig_level)) %>% 
  kableExtra::save_kable(paste0(res_dir, "/sign.genes.png"))

res_region <- topTable(fit, coef="regionOFC", n=Inf, p.value=1)

write.table(res_region, paste0(res_dir, "/de_limma.txt"), sep="\t", row.names=F)

high_OFC_FDR_001 <- res_region %>%  filter(t < 0 & adj.P.Val < 0.01)
low_OFC_FDR_001 <- res_region %>%  filter(t > 0 & adj.P.Val < 0.01)

```

```{r DE p values as manhattan plot}
#with input from Daniel Roelfs' blog

chr_order <- c("1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22","X","Y")

res$chromosome_name <- factor(res$chromosome_name, levels = chr_order)


#create a cumulative column for base positions
data_cum <- res %>% 
  group_by(chromosome_name) %>% 
  summarise(max_bp = max(end_position)) %>% 
  mutate(bp_add = lag(cumsum(as.numeric(max_bp)), default = 0)) %>% #Since we don‚Äôt need to add anything to the first chromosome, we move everything one row down (using the lag() function)
  select(chromosome_name, bp_add)

data_cum$chromosome_name <- factor(data_cum$chromosome_name, levels = chr_order)


res <- res %>% 
  inner_join(data_cum, by = "chromosome_name") |>
  mutate(bp_cum = as.numeric(end_position) + bp_add)

#calculate centre position of each chromosome
axis_set <- res %>% drop_na(chromosome_name) %>% 
  group_by(chromosome_name) %>% 
  summarize(center = mean(bp_cum))

axis_set$chromosome_name <- factor(axis_set$chromosome_name, levels = chr_order)

#plot Manhattan plot
#find the nomiinal limmit for FDR significance
sig <- res %>% filter(adj.P.Val < 0.01) %>% slice_max(P.Value) %>% select(P.Value)
sig <- sig$P.Value

manhplot <- 
res %>% drop_na(chromosome_name) %>% 
  ggplot( aes(
  x = bp_cum, y = -log10(P.Value),
  color = as_factor(chromosome_name), size = -log10(P.Value)
)) +
  geom_hline(
    yintercept = -log10(sig), color = "grey40",
    linetype = "dashed"
  ) +
  geom_point(alpha = 0.75) +
  scale_x_continuous(
    label = factor(axis_set$chromosome_name, levels = chr_order),
    breaks = axis_set$center#,
 #   expand = c(0,0)  #remove air on each side
  ) +
 scale_y_continuous(expand = c(0, 0)#, limits = c(0, ylim)
                    ) +
  scale_color_manual(values = rep( #colour evry other chromosome
    c("#276FBF", "#183059"),
    unique(length(axis_set$chromosome_name))
  )) +
  scale_size_continuous(range = c(0.5, 3)) +
  labs(
    x = NULL,
    y = "-log10(p)"
  ) +
  theme_minimal() +
  theme(
    legend.position = "none",
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
#    axis.title.y = element_markdown(),
    axis.text.x = element_text(angle = 60, size = 8, vjust = 0.5)
  )


ggsave(manhplot, file = paste0(res_dir, "/p_values_sign_genes_manhattan.png" ))

  
```



```{r plot DE genes}
#in order to visualise expression, we need the samples as rows and gene expression + covariates as columns
## Plot significant genes
library(ggsci)
library(ggpubr)

col <- get_palette("aaas", 10)
colData.filt <- subset(colData, rownames(colData) %in% SampleID )


df <- cpm(y, log=TRUE, prior.count=3) #convert counts to normalised cpm

df <- df %>% t() %>% data.frame() 



df_top10  <- df[rownames(head(res,10)), ] #only keep the top 10 significant genes

df_top10 <- df_top10 %>% t() %>% data.frame()     #have genes as columns
colnames(df_top10) <- head(res,10)$external_gene_name #use gene symbols in stead of ensembl codes
df_top10 <- merge(df_top10,colData.filt,by=0) 

df_top10 <- df_top10 %>% rename("SampleID" = Row.names )


#IA's plotting
# glist <- lapply(2:11, function (x) {
#   ggplot() + 
#     geom_boxplot(data=df,aes(x = below12, y = df[,x]), color ="black",size=0.7, outlier.shape=NA, fill="white") +
#     geom_point(data=df,aes(x = below12, y = df[,x], color = below12, fill=below12), position=position_jitterdodge(), pch=21,size=3.5, color="black", alpha=0.85) + 
#     labs(title=colnames(df)[x],x="",y="") +
#     scale_colour_manual(values=col[c(2,9,8)]) +
#     scale_fill_manual(values=col[c(2,9,8)]) +
#     theme_classic() +
#     theme(axis.text.x=element_text(size=20,color="black", angle=0, hjust=0.5),
#           axis.text.y=element_text(size=20,color="black"),
#           axis.title=element_text(size=16),
#           plot.title=element_text(size=20,hjust=0.5),
#           legend.text=element_text(size=20),
#           legend.title=element_blank(),
#           plot.margin=unit(c(0,0,0,0),"cm"),
#           panel.background=element_rect(linetype="solid", color="black", size=1)) 
# })
# 
# 
# annotate_figure(ggarrange(plotlist=glist,ncol=5,nrow=2,common.legend=T,legend="none"),
#                 left=text_grob("Normalized expression",size=20,rot=90))
# 

#prepare for flexible plotting
df_long <- 
  df %>% 
  rownames_to_column(var = "SampleID") %>% 
  pivot_longer(cols = -1, names_to = "gene_id", values_to = "log_cpm") 

df_long <- 
  df_long %>% 
  left_join(info_CC, by= c( "SampleID" ="sampleID"))

df_long$below12 <- str_replace(df_long$below12, "1", "<12")
df_long$below12 <- str_replace(df_long$below12, "0", ">12")

df_long$below12 <- factor(df_long$below12, levels =  c("<12", ">12"))

df_long <- df_long %>%  rename("Age_group" = below12) 

plot_expr <- 
  df_long %>% 
  ggplot(aes(x=Age_group, y= log_cpm)) + 
    geom_boxplot( color ="black",size=0.7, outlier.shape=NA, fill="white") +
    geom_point(aes( colour= Age_group, fill = Age_group), position= "jitter") +
  facet_wrap(~gene_id, scales = "free_y") +
      scale_colour_manual(values=col[c(1,6)]) +
    scale_fill_manual(values=col[c(1,6)]) +
  labs(title= paste0("Normalised expression, 10 significant DE genes, ", analysis)) +
  theme_bw()

#ggsave(plot_expr, file = paste0(res_dir, "/plot_expr_top10sign.pdf" ))  
  

```

```{r plot top DE genes expression BrainRegion}
colData.filt <- subset(colData, rownames(colData) %in% SampleID )


df <- cpm(y, log=TRUE, prior.count=3) #convert counts to normalised cpm. genes as rownames





df_top10  <- df[rownames(head(res_region,10)), ] #only keep the top 10 significant genes

df_top10 <- df_top10 %>% t() %>% data.frame()     #have genes as columns
colnames(df_top10) <- head(res,10)$external_gene_name #use gene symbols in stead of ensembl codes

df_top10 <- df_top10 %>% rownames_to_column(var = "SampleID" )

#prepare for flexible plotting

df <- df %>% t() %>% data.frame() 
df_long <- 
  df %>% 
  rownames_to_column(var = "SampleID") %>% 
  pivot_longer(cols = -1, names_to = "gene_id", values_to = "log_cpm") 

df_long <- 
  df_long %>% 
  left_join(colData_all, by= c( "SampleID" ="sampleID")) %>% 
  left_join(genemap2, by=c("gene_id"= "ensembl_gene_id"))

df_long$below12 <- str_replace(df_long$below12, "1", "<12")
df_long$below12 <- str_replace(df_long$below12, "0", ">12")

df_long$below12 <- factor(df_long$below12, levels =  c("<12", ">12"))

df_long <- df_long %>%  rename("Age_group" = below12) 

plot_expr <- 
  df_long %>% 
    filter(external_gene_name %in% colnames(df_top10) ) %>% 
  ggplot(aes(x=region, y= log_cpm)) + 
    geom_boxplot( color ="black",size=0.7, outlier.shape=NA, fill="white") +
    geom_point(aes( colour= region, fill = region), position= "jitter") +
  facet_wrap(~external_gene_name, scales = "free_y") +
      scale_colour_manual(values=col[c(1,6)]) +
    scale_fill_manual(values=col[c(1,6)]) +
  labs(title= paste0("Normalised expression, 10 significant DE genes, ", analysis)) +
  theme_bw()

ggsave(plot_expr, file = paste0(res_dir, "/plot_expr_top10sign.pdf" ))  
  
#plot expression highest in OFC/ CC separately
plot_expr_highOFC <- 
  df_long %>% 
    filter(external_gene_name %in% high_OFC_FDR_001$external_gene_name[1:10] ) %>% 
  ggplot(aes(x=region, y= log_cpm)) + 
    geom_boxplot( color ="black",size=0.7, outlier.shape=NA, fill="white") +
    geom_point(aes( colour= region, fill = region), position= "jitter") +
  facet_wrap(~external_gene_name, scales = "free_y") +
      scale_colour_manual(values=col[c(1,6)]) +
    scale_fill_manual(values=col[c(1,6)]) +
  labs(title= paste0("Normalised expression, 10 significant genes higher in OFC")) +
  theme_bw()

plot_expr_highCC <- 
  df_long %>% 
    filter(external_gene_name %in% low_OFC_FDR_001$external_gene_name[1:10] ) %>% 
  ggplot(aes(x=region, y= log_cpm)) + 
    geom_boxplot( color ="black",size=0.7, outlier.shape=NA, fill="white") +
    geom_point(aes( colour= region, fill = region), position= "jitter") +
  facet_wrap(~external_gene_name, scales = "free_y") +
      scale_colour_manual(values=col[c(1,6)]) +
    scale_fill_manual(values=col[c(1,6)]) +
  labs(title= paste0("Normalised expression, 10 significant genes higher in OFC")) +
  theme_bw()

ggsave(plot_expr_highOFC, file = paste0(res_dir, "/plot_expr_top10sign_highOFC.pdf" ))  
ggsave(plot_expr_highCC, file = paste0(res_dir, "/plot_expr_top10sign_highCC.pdf" ))  
  

```

```{r variance in age groups}
library(rstatix)

DE_genes_0.05 <- 
  res %>% rownames_to_column(var = "gene_id") %>% filter(adj.P.Val < 0.05) %>% select(external_gene_name)

#look at 10 most significant genes

df_long_sd <- 
  df_long %>% 
  select(SampleID, Age_group, gene_id, log_cpm) %>% 
  tidyr::drop_na() %>% 
  filter(gene_id %in% genemap2$ensembl_gene_id) %>% 
  group_by(Age_group, gene_id) %>% 
  summarise(sd = sd(log_cpm)) %>% 
  ungroup()# %>% 
  #ggplot(aes(x= Age_group, y= sd)) + geom_boxplot() + geom_jitter() #%>% 
  t_test(sd  ~ Age_group) 
 
#interesting trend. Should we look for genes with high difference in variance? 
cpm_all <- cpm(y, log=TRUE, prior.count=3) #convert counts to normalised cpm

cpm_all <- cpm_all %>% t() %>% data.frame()     #have genes as columns
cpm_all_long <- 
  cpm_all %>%  rownames_to_column(var = "SampleID") %>% 
  pivot_longer(cols = -1, names_to = "ensembl_gene_id", values_to = "log_cpm")

#change gene name to symbol
cpm_all_long <- 
  cpm_all_long %>% 
  left_join(select(genemap2, ensembl_gene_id, external_gene_name) , by=c("ensembl_gene_id"))  #add in symbol name

cpm_all_long <- 
  cpm_all_long %>% rename("gene_id" = external_gene_name)

cpm_all_long <- 
  cpm_all_long %>% 
  left_join(rownames_to_column(colData.filt, var= "SampleID"), by="SampleID")

cpm_all_long$below12 <- str_replace(cpm_all_long$below12, "1", "<12")
cpm_all_long$below12 <- str_replace(cpm_all_long$below12, "0", ">12")
cpm_all_long$below12 <- factor(cpm_all_long$below12, levels =  c("<12", ">12"))
cpm_all_long <- cpm_all_long %>%  rename("Age_group" = below12)

genes_sd_diff <- 
  cpm_all_long %>% 
  select(SampleID, Age_group, gene_id, log_cpm, ensembl_gene_id) %>% 
    filter(ensembl_gene_id %in% genemap2$ensembl_gene_id) %>% 
  group_by(Age_group, gene_id) %>% 
  summarise(sd = sd(log_cpm)) %>% 
  ungroup() %>% 
  pivot_wider(id_cols = gene_id, names_from = Age_group, values_from = sd) %>% 
  mutate(sd_diff = `<12` - `>12`) %>% 
  arrange(desc(sd_diff)) %>% 
  head(n= 20) %>% 
  select(gene_id)

#plot_expr <- 
  cpm_all_long %>% 
    filter(gene_id %in% genes_sd_diff$gene_id) %>% 
    ggplot(aes(x=Age_group, y= log_cpm)) + 
    geom_boxplot(  outlier.shape=NA, fill="white") +
    geom_point(aes( colour = AGE), position= "jitter") +
  facet_wrap(~gene_id, scales = "free_y") +
 #     scale_colour_manual(values=col[c(1,6)]) +
 #   scale_fill_manual(values=col[c(1,6)]) +
  #labs(title= paste0("Normalised expression, 20 genes with high differense in SD, ", analysis)) +
  theme_bw()

  #For CC, it is clear that the largest difference in sd is due to 1 outlier sample in many cases, and it is not the AGE<2 samples
  #For OFC, there are more samples contributing to high sd.

#It could be interesting to analyse all genes 1-by-1 and test for differences in variance of expression in children vs adolescents. This could be an indication of genes that come under strong stoichiometric constraint during adolescence

sd_diff_genes<-   df_long_sd %>%  
    pivot_wider(id_cols = gene_id, names_from = Age_group, values_from = sd) %>% 
    mutate(sd_diff= `>12`- `<12`) %>%  
    arrange(sd_diff) %>% 
    left_join(select(hsa_path_eg, ensembl_gene_id, external_gene_name, go_id, name_1006) , 
              by=c("gene_id" ="ensembl_gene_id")) %>% 
    drop_na() %>% 
    distinct() %>% 
    filter(sd_diff < -0.5)

#top 6 GO-term (already used arrange() to sort above)
GO_top_sd_diff <- sd_diff_genes %>% 
  filter(name_1006 != "") %>% 
  select(name_1006) %>% 
  drop_na() %>% 
  distinct() %>% head(n=6)

#OFC: GO-terms of genes with more variance in childhood includes membrane (CACNA1, PAQR6), G-protein signaling and mitochondrial genes.
  
  cpm_all_long %>% 
    filter(ensembl_gene_id %in% sd_diff_genes$gene_id) %>% 
    left_join(sd_diff_genes, by=c("ensembl_gene_id"="gene_id")) %>%
    filter(name_1006 %in% GO_top_sd_diff$name_1006) %>% 
  ggplot(aes(x=AGE, y= log_cpm, colour=gene_id)) +
  geom_point()+ 
    facet_wrap(~name_1006, scales = "free_y") +
  geom_smooth(method = lm, formula = y ~ poly(x, 2), se = FALSE) 
 
  
#Pick out the 3 most extreme examples of sd difference among the 6 top GO-terms
min_sd_diff_GO <- 
  cpm_all_long %>%
  filter(ensembl_gene_id %in% sd_diff_genes$gene_id) %>%
  left_join(sd_diff_genes, by=c("ensembl_gene_id"="gene_id")) %>%
  filter(name_1006 %in% GO_top_sd_diff$name_1006)  %>% arrange(sd_diff) %>%
  select(gene_id, sd_diff, name_1006) %>%  
  group_by(name_1006) %>%  select(gene_id, name_1006, sd_diff) %>% distinct() %>%
  slice_head(n=3)

#plot gene expression of the sd_diff examples for each GO-term.
sd_diff_GO<- 
  cpm_all_long %>%
  filter(ensembl_gene_id %in% sd_diff_genes$gene_id) %>%
  left_join(sd_diff_genes, by=c("ensembl_gene_id"="gene_id")) %>%
  filter(name_1006 %in% GO_top_sd_diff$name_1006) %>% 
  filter(gene_id %in% min_sd_diff_GO$gene_id) %>%
  ggplot(aes(x=AGE, y= log_cpm, colour=gene_id)) +
    geom_point() +
    facet_wrap(~name_1006, scales = "free_y") +
    geom_smooth(method = lm, formula = y ~ poly(x, 2), se = FALSE)

ggsave(sd_diff_GO, file = paste0(res_dir, "sd_diff_GO_expr.pdf"))

#save cpm values
write_tsv(select(cpm_all_long, -CDEATHOFF), file = paste0(res_dir, "cpm_all_long.txt") )
```

```{r pairs of switches}
#Kang et al
#IGF2 in fig 2c
#DCX in fig 5d


#Bar-Shira et al's selection:
#GRIN2A/GRIN2B #mostly embryonic
#GABRA3/ GABRA6
#GLRA2/GLRA3
#HTR1A/ HTR5A

gene_pair <- c("GRIA1", "GRIA2")
gene_pair <- c("GRIA4", "GRIA2")
gene_pair <- c("GRIN2A", "GRIN2B")

gene_pair <- c("SNAP23", "SNAP25")

  cpm_all_long %>% 
    filter(gene_id %in% gene_pair) %>% 
#      filter(gene_id %in% c("GLRA2", "GLRA3")) %>% 
#        filter(gene_id %in% c("HTR1A", "HTR5A")) %>% 
#  filter(gene_id %in% c("GABRA3", "GABRA6")) %>% 
    ggplot(aes(x=AGE, y= log_cpm, colour=gene_id)) +
  geom_point()+
  geom_smooth(se = FALSE) +
        scale_colour_manual(values=col[c(1,6)])


  cpm_all_long %>% 
    filter(gene_id %in% c("GRIN2A", "GRIN2B")) %>% 
#      filter(gene_id %in% c("GLRA2", "GLRA3")) %>% 
#        filter(gene_id %in% c("HTR1A", "HTR5A")) %>% 
#  filter(gene_id %in% c("GABRA3", "GABRA6")) %>% 
    ggplot(aes(x=AGE, y= log_cpm, colour=gene_id)) +
  geom_point()+
  geom_smooth(se = FALSE) +
        scale_colour_manual(values=col[c(1,6)])

```

```{r import age expression data from Berchtold 2013}
install.packages("pdftools") #tool to scrape data from pdfs
library(pdftools)

#none of these work for this data. Must probably copy into excel, before import. 
#berchtold_tableS5 <- pdf_text("/Users/asbjorh/Downloads/1-s2.0-S0197458012006124-mmc5.pdf")
#berchtold_tableS5 <- PDE::PDE_analyzer("/Users/asbjorh/Downloads/1-s2.0-S0197458012006124-mmc5.pdf")

```



```{r find neuronal function genes}

analysis <- "switches/OFC"
analysis <- "switches/CC"

res_dir <- paste0("~/proj_Maryland_WGCNA/analysis/", analysis, "/")

#Bar-Shira et al 2015 call these potential switch pairs "condition-dependent variants" or CDVs

# Specifically, we used the KEGG
# pathways repository [2] to focus on proteins that participate in synaptic pathways, including
# signal transduction pathways of all neurotransmitters (a total of 17 KEGG pathways). We then
# used KEGG to define subgroups of functionally-related proteins which are likely to contain
# CDVs (see Methods). Then, we calculated the similarity of the two amino-acid sequences of
# each candidate pair, and kept pairs with sequence similarity above 30% (see Methods). Low
# sequence similarity is usually associated with different functionality and dissimilar protein
# sequences can be excluded from consideration [40]

library(KEGGREST)
library(org.Hs.eg.db)

#the following KEGG codes are linked to neuronal functions, neurodegenerative disorders and substance dependence. They are taken from Table2 in Bar-Shira et al 2015. 
neuronal_KEGG <- c(
  "path:hsa04020",
  "path:hsa04724",
  "path:hsa04725",
  "path:hsa04726",
  "path:hsa04727",
  "path:hsa04728",
  "path:hsa04730",
  "path:hsa05010",
  "path:hsa05012",
  "path:hsa05014",
  "path:hsa05016",
  "path:hsa05030",
  "path:hsa05031",
  "path:hsa05032",
  "path:hsa05033",
  "path:hsa05034",
    "path:hsa04080"
)

#get the entrez ID from genes that are in these KEGG pathways
hsa_path_eg  <- 
  keggLink(target = "hsa", source = neuronal_KEGG) %>%
  tibble(gene = ., KEGG_pathway = sub("hsa:", "", names(.))) %>% 
   separate_wider_delim(gene, delim = ":", names = c(NA, "entrezgene_id")) %>% 
  mutate(KEGG_pathway= str_replace_all(.$KEGG_pathway, "path:hsa", "")) 

neuronal_KEGG_codes <- str_remove_all(neuronal_KEGG, pattern = "path:")
neuronal_KEGG_names <-
    KEGGREST::keggList("pathway", "hsa"  ) %>%   
  tibble::enframe(name = "pathway_id", value = "pathway") %>% 
    dplyr::filter(pathway_id %in% neuronal_KEGG_codes)

neuronal_KEGG_names$KEGG_pathway <- str_remove_all(neuronal_KEGG_names$pathway_id, "hsa")

neuronal_KEGG_names$pathway <- str_replace(neuronal_KEGG_names$pathway, " \\s*\\([^\\)]+\\)", replacement = "")

neuronal_KEGG_names$pathway <- str_replace(neuronal_KEGG_names$pathway, " - Homo sapiens", replacement = "")

#entrez stored as numbers by default. Need character. 
genemap2$entrezgene_id <- as.character(genemap2$entrezgene_id) 

#get more gene info. genemap2 is already reduced to protein-coding and lncRNA
hsa_path_eg <- 
  hsa_path_eg %>% 
  left_join(select(neuronal_KEGG_names, pathway, KEGG_pathway ), by= "KEGG_pathway") %>% 
  left_join(select(tibble(genemap2), entrezgene_id, ensembl_gene_id, external_gene_name, go_id, name_1006 ), by= "entrezgene_id") %>% 
  tidyr::drop_na()

```


```{r find paralog gene pairs}
#of neuro-KEGG genes, find paralogs
paralogs_neuro <- getBM(
  attributes = c( "ensembl_gene_id", "external_gene_name",  "hsapiens_paralog_ensembl_gene", "hsapiens_paralog_associated_gene_name" , "hsapiens_paralog_perc_id"), 
  mart= ensembl, 
  filters = "external_gene_name", 
  values = hsa_path_eg$external_gene_name)

#find any paralog pairs
paralogs <- getBM(
  attributes = c(  "ensembl_gene_id", "external_gene_name",  "hsapiens_paralog_ensembl_gene", "hsapiens_paralog_associated_gene_name" , "hsapiens_paralog_perc_id"), 
  mart= ensembl, 
  filters = "ensembl_gene_id", 
  values = genemap2$ensembl_gene_id)

paralogs_neuro <-
  paralogs_neuro %>% tidyr::drop_na()

#add GO term and KEGG pathway
paralogs_neuro <-
  paralogs_neuro %>% 
  left_join(select(hsa_path_eg,   KEGG_pathway, go_id, name_1006, external_gene_name), by ="external_gene_name") %>%
  rename("go_name" = name_1006)


#Bar-Shira et al used 30% sequence similarity as cut-off for possible CDVs
paralogs_neuro_sim <-
  paralogs_neuro %>%
  filter(hsapiens_paralog_perc_id>= 30) 
#this is gene similarity, while the paper used "protein pairs with amino acid sequence similarity lower than 30%";
# Protein sequences were aligned using the Needleman-Wunsch global algorithm. Following the
# definition used for global alignment in BLAST 2 Sequences [78] we used blosum62 as the scoring
# matrix, and set the gap costs to 11 for gap existence and 1 for each extension. The sequence
# similarity was defined as the fraction of identical residues out of the number of residues in the
# longer sequence.

#Quantify dissimilarity between expression profiles
#the Spearman correlation between the expression profiles of each pair of genes. Analysis was limited to differentially expressed genes, by excluding genes whose expression range (maximum‚Äìminimum) was lower than 1.5 in log2 scale

#find genes that vary over age, and exclude the rest from analysis
genes_range1.5<- 
  cpm_all_long %>% 
  select(SampleID, log_cpm, gene_id) %>% 
  group_by(gene_id) %>% 
  mutate(max= max(log_cpm), min= min(log_cpm)) %>% 
  mutate(range= max-min) %>% ungroup() %>% 
  select(gene_id, range) %>% distinct() %>%  
  filter(range>1.5) %>% 
  select(gene_id)

paralogs_neuro_sim <- 
  filter(paralogs_neuro_sim, external_gene_name %in% genes_range1.5$gene_id)
```

```{r correlation in expression}
#Simple method: find pearson correlation of pairs, and look for negatively correlated expression

cor <- cpm_all %>% 
  dplyr::select(colnames(cpm_all)[colnames(cpm_all) %in% paralogs_neuro_sim$ensembl_gene_id] | colnames(cpm_all)[colnames(cpm_all) %in% paralogs_neuro_sim$hsapiens_paralog_ensembl_gene] ) %>% 
  cor()                    # get all correlations of neuronal genes with paralogs or that are paralogs of these 
  

cor[lower.tri(cor)] <- NA #removes the reverse correlation

cor_paralogs_neuro_sim <- 
  cor %>% 
 data.frame() %>%           # save result as a dataframe
  mutate(v1 = row.names(.)) %>%  # add row names as a column
  pivot_longer(cols = -v1, names_to = "v2", values_to = "cor") %>%        # reshape data
  filter(v1 != v2) %>%    # keep pairs that v1 matches v2, but are not the same
  drop_na() #remove the reverse correlations



#find the gene pairs mostly negatively correlated
neg_corr <- cor_paralogs_neuro_sim %>% 
  arrange(cor) %>% 
  head(n=10)

neg_corr_membrane <- cor_paralogs_neuro_sim %>% 
  arrange(cor) %>% 
  filter(cor < 0) %>% 
  filter(v1 %in% hsa_path_eg$ensembl_gene_id[hsa_path_eg$name_1006=="membrane"])

#visualise gene expression of negatively correlated pairs
  cpm_all_long %>% 
     mutate(pair = case_when(
    ensembl_gene_id  %in% neg_corr[1,] ~ "1",
    ensembl_gene_id  %in% neg_corr[2,] ~ "2",
    ensembl_gene_id  %in% neg_corr[3,] ~ "3",
    ensembl_gene_id  %in% neg_corr[4,] ~ "4",
    TRUE ~ NA)) %>% 
    drop_na %>%
    ggplot(aes(x=AGE, y= log_cpm, colour=gene_id)) +
  geom_point()+ 
    facet_wrap(~pair, scales = "free_y") +
  geom_smooth(se = FALSE) +
        scale_colour_manual(values=col) 
  
  #visualise gene expression of negatively correlated pairs
  cpm_all_long %>% 
     mutate(pair = case_when(
    ensembl_gene_id  %in% neg_corr_membrane[1,] ~ "1",
    ensembl_gene_id  %in% neg_corr_membrane[2,] ~ "2",
    ensembl_gene_id  %in% neg_corr_membrane[3,] ~ "3",
    ensembl_gene_id  %in% neg_corr_membrane[4,] ~ "4",
    TRUE ~ NA)) %>% 
    drop_na %>%
    ggplot(aes(x=AGE, y= log_cpm, colour=gene_id)) +
  geom_point()+ 
    facet_wrap(~pair, scales = "free_y") +
  geom_smooth(se = FALSE) +
        scale_colour_manual(values=col) 
  
  #Could be an idea to do an xy scatter plot of gene1 vs gene2 (shading points by subject age)
  
  
  
  
  #Smoothing splines: http://users.stat.umn.edu/~helwig/notes/smooth-spline-notes.html
  ?stats::smooth.spline()
  
  test_gene <- cpm_all_long %>% 
    filter(gene_id == "KCNQ5")
  
  test.smsp <- stats::smooth.spline(x=test_gene$AGE, y= test_gene$log_cpm, nknots = 10)
  
  
```



```{r age trend significant coefficient}
analysis <- "age_trend_genes_OFC"
cpm_all_long <- cpm_all_long_OFC
#analysis <- "age_trend_genes_CC"
#cpm_all_long <- cpm_all_long_CC

res_dir <- paste0("~/proj_Maryland_WGCNA/analysis/", analysis, "/")

#work on subset of genes: any genes with linear age trend, and a certain range of expression 
#cor_subset_genes <- unique(cpm_all_long$ensembl_gene_id[cpm_all_long$gene_id %in% genes_range1.5$gene_id & cpm_all_long$ensembl_gene_id %in% age_trend_genes_linear$ensembl_gene_id ])

#work on subset of genes: any genes that have a paralog gene
#cor_subset_genes <- paralog_age_trend_genes$ensembl_gene_id
#cor_subset_genes <- genemap2$ensembl_gene_id[genemap2$ensembl_gene_id %in% paralogs$ensembl_gene_id | genemap2$ensembl_gene_id %in% paralogs$hsapiens_paralog_ensembl_gene]

#cor_subset <- cpm_all[, colnames(cpm_all) %in% cor_subset_genes]

#Work on all genes
cor_subset_genes <- unique(cpm_all_long$ensembl_gene_id)

res_poly_all <- list()
models_poly_all <- list() 
poly_coeff_pvalue <- list()
lin_coeff_value <- list()
counter <- 0

for(gene in cor_subset_genes){
  test_gene <- cpm_all_long %>%
    filter(ensembl_gene_id == gene)
  
  poly_mod <- 
    lm(log_cpm ~ poly(AGE, 2), data= test_gene)
  res_poly <- poly_mod$residuals
  names(res_poly) <- test_gene$SampleID
  
  res_poly_all[[gene]] <- res_poly
  models_poly_all[[gene]] <- poly_mod
  poly_coeff_pvalue[[gene]] <- summary(poly_mod)$coefficients[,4]
  lin_coeff_value[[gene]] <- poly_mod$coefficients[2]
  
  counter <- counter + 1;
                  if(counter %in% seq(0, length(cor_subset_genes), round(length(cor_subset_genes))/10))
                      print(paste(round(counter/length(cor_subset_genes))*100), "% has been processed")
}

res_poly_all_df <-  do.call("rbind", res_poly_all)
poly_coeff_pvalue_df <- do.call("rbind", poly_coeff_pvalue)
lin_coeff_value_mtx <- do.call("rbind", lin_coeff_value)

poly_coeff_pvalue_df <-
  base::as.data.frame(poly_coeff_pvalue_df) %>% 
  rownames_to_column(var = "ensembl_gene_id")

poly_coeff_pvalue_df$lin_coeff <- as.vector(lin_coeff_value_mtx)

coeff_hist <- poly_coeff_pvalue_df %>% 
  pivot_longer(cols = -c("ensembl_gene_id", "lin_coeff"), names_to = "coeff", values_to = "p") %>% 
  filter(coeff != "(Intercept)", p<0.01) %>%  
  ggplot() + 
  geom_histogram(mapping = aes(x=p, fill= coeff), colour = "black") +
  scale_fill_brewer(palette= "Dark2")


age_trend <- poly_coeff_pvalue_df %>% 
  pivot_longer(cols = -c("ensembl_gene_id", lin_coeff), names_to = "coeff", values_to = "p") %>% 
  filter(coeff != "(Intercept)") %>% 
  filter(p<0.01) 

age_trend_linear <- poly_coeff_pvalue_df %>% 
  select(ensembl_gene_id, lin_coeff, `poly(AGE, 2)1`) %>% 
  rename("p" = `poly(AGE, 2)1`) 

age_trend_genes <-  age_trend %>% 
  filter(p< 0.01) %>% 
  select(ensembl_gene_id) %>% distinct()

age_trend_genes_linear <- age_trend %>% 
  filter(p< 0.01 & coeff=="poly(AGE, 2)1") %>% 
  select(ensembl_gene_id) %>% distinct()

age_trend_genes_linear_adj <- 
  age_trend_linear %>% 
  rstatix::adjust_pvalue( p = "p", output.col = "p_linear_adj", method = "fdr") 

top10_linear_trend <- 
  age_trend %>% filter(p< 0.05 & coeff=="poly(AGE, 2)1") %>% 
  arrange(p) %>% 
  head(n=10) %>%  
  select(ensembl_gene_id)

age_trend_linear <- 
  cpm_all_long %>% 
  filter(ensembl_gene_id %in% top10_linear_trend$ensembl_gene_id) %>% 
  ggplot(aes(x=AGE, y= log_cpm)) + geom_point() +
  facet_wrap(~gene_id, scales = "free_y") +
  geom_smooth(method = lm, formula = y ~ poly(x, 2), se = FALSE) +
  scale_colour_brewer(
   # breaks= vis_genes, 
    palette = "Dark2" )

ggsave(coeff_hist,  file = paste0(res_dir, "/coeff_hist.pdf" ))    
ggsave(age_trend_linear,  file = paste0(res_dir, "/plot_top10_AGE_linear.pdf" )) 

write_tsv(age_trend_genes, file = paste0(res_dir, "/age_trend_genes.txt" ))
write_tsv(age_trend_genes_linear_adj, file = paste0(res_dir, "/age_trend_linear.txt" ))

write.csv(res_poly_all_df, file = paste0(res_dir, "/res_poly_all_df.txt" ))
```

Investigate correlation pairs where genes have the same GO-annotation
```{r create table of GO-terms}

GOall <- AnnotationDbi::select(org.Hs.eg.db, columns = c("ENSEMBL" , "SYMBOL" , "GO"), keys= unique(age_trend_genes_linear_adj$ensembl_gene_id), keytype = "ENSEMBL") 

GOall_BP <- 
  GOall %>%  
  tidyr::drop_na() %>%  
  filter(ONTOLOGY =="BP")

descr <- clusterProfiler::go2term(GOall_BP$GO)

GOall_BP <- 
  GOall_BP %>% 
  dplyr::select(-EVIDENCE) %>% 
  distinct() %>% 
  left_join(descr, by = c("GO" = "go_id"))

pairs_GO_Var2 <- pairs %>% left_join(select(GOall_BP, ENSEMBL, GO), by= c("Var2" = "ENSEMBL"), relationship = "many-to-many") %>% dplyr::rename("Var2_GO" = GO) %>% tidyr::drop_na()
pairs_GO_Var1 <- pairs %>% left_join(select(GOall_BP, ENSEMBL, GO), by= c("Var1" = "ENSEMBL"), relationship = "many-to-many") %>% dplyr::rename("Var1_GO" = GO) %>%  tidyr::drop_na()
pairs_GO <- pairs_GO_Var1 %>% left_join(pairs_GO_Var2, by= c("Var1", "Var2")) %>% tidyr::drop_na()
pairs_GO_equal <- pairs_GO %>%  filter(Var1_GO == Var2_GO)

pairs_GO_equal <- 
  pairs_GO_equal %>% 
  select(-Var2_GO) %>% 
  rename("GO" = Var1_GO) %>% 
  left_join(select(GOall_BP, GO, Term), by = "GO") %>%  #insert GO term description
    distinct()

#Problem: many genes have many GO-terms. 
#restrict pairs analysis to the enriched GO-terms?
GO_enrich <- 
  GOall_BP %>% 
  filter(GO %in% gse@result$ID[gse@result$p.adjust < sig_level])

ego@result %>% filter(p.adjust < sig_level) %>% filter(ID %in% gse@result$ID[gse@result$p.adjust < sig_level]) %>% dim()

```


```{r genes of interest correlation residuals and expression levels}


 analysis <- "switches/opposite_linear/OFC"
 cpm_all_long_OFC <- 
   read_tsv("~/proj_Maryland_WGCNA/analysis/cpm_all_long_OFC.txt" )
 age_trend_genes_linear_adj <-
   read_tsv("~/proj_Maryland_WGCNA/analysis/age_trend_genes_OFC/age_trend_linear.txt")
 cpm_all_long <- cpm_all_long_OFC

#analysis <- "switches/opposite_linear/CC"
#cpm_all_long_CC <- 
 # read_tsv("~/proj_Maryland_WGCNA/analysis/cpm_all_long_CC.txt" )
#age_trend_genes_linear_adj <-
 # read_tsv("~/proj_Maryland_WGCNA/analysis/age_trend_genes_CC/age_trend_linear.txt")
#cpm_all_long <- cpm_all_long_CC


coeff_min <- 0#the minimum linear coefficient included in the analysis
sig_level <- 0.01
res_dir <- paste0("~/proj_Maryland_WGCNA/analysis/", analysis, "/")

library(corrplot)
library(directlabels)
library(rstatix)

library(org.Hs.eg.db)
library(AnnotationDbi)
#cpm_all_long <- cpm_all_long %>% 
 # left_join(info_OFC, by=c("SampleID"= "sampleID"))

# #genes in paralog pairs that also have age trends (linear coefficient)
# paralog_age_trend_genes1 <- 
#   paralogs %>%
#   filter(hsapiens_paralog_perc_id>= 30) %>% 
#   filter(ensembl_gene_id %in% age_trend_genes$ensembl_gene_id & hsapiens_paralog_ensembl_gene %in% age_trend_genes$ensembl_gene_id) %>% 
#   select(ensembl_gene_id) %>% distinct() 
# 
# paralog_age_trend_genes2 <- 
#   paralogs %>%
#   filter(hsapiens_paralog_perc_id>= 30) %>% 
#   filter(ensembl_gene_id %in% age_trend_genes$ensembl_gene_id & hsapiens_paralog_ensembl_gene %in% age_trend_genes$ensembl_gene_id) %>% 
#   select(hsapiens_paralog_ensembl_gene) %>% 
#   rename("ensembl_gene_id" = hsapiens_paralog_ensembl_gene) %>% distinct() 
# 
# paralog_age_trend_genes <- bind_rows(paralog_age_trend_genes1, paralog_age_trend_genes2) %>% distinct()
# 
# cor_subset_genes <- paralog_age_trend_genes$ensembl_gene_id
# 
# cor_subset <- cpm_all[, colnames(cpm_all) %in% cor_subset_genes]
# cor_subset_genes <- cor_subset_genes[cor_subset_genes %in% colnames(cor_subset) ]
# 
# 
# #use all genes
# #cor_subset <- cpm_all 
# 
# #If n genes > 2000, we have to pick out the pairs we're interested in
# #all paralog pairs
# pairs <- 
#   paralogs %>% 
#   filter(ensembl_gene_id %in% cor_subset_genes & hsapiens_paralog_ensembl_gene %in% cor_subset_genes) %>% 
#   filter(hsapiens_paralog_perc_id > 30) %>% 
#   select(ensembl_gene_id, hsapiens_paralog_ensembl_gene) %>%  
#   distinct()

#all gene pairs with significant linear age-coefficient in the opposite direction
pos_linear <- 
  age_trend_genes_linear_adj %>% 
  select(-p) %>% 
  filter(p_linear_adj < sig_level & lin_coeff >0) %>% 
  filter(abs(lin_coeff) >= coeff_min)
  
neg_linear <- 
  age_trend_genes_linear_adj %>% 
  select(-p) %>% 
  filter(p_linear_adj < sig_level & lin_coeff <0)  %>% 
  filter(abs(lin_coeff) >= coeff_min)

pairs <- expand.grid(pos_linear$ensembl_gene_id, neg_linear$ensembl_gene_id) #Create a data frame from all combinations of the 
                                            #supplied vectors
#only keep genes with a certain range (not too flat curve over age)
genes_range1.5<- 
  cpm_all_long %>% 
  select(SampleID, log_cpm, ensembl_gene_id) %>% 
  group_by(ensembl_gene_id) %>% 
  mutate(max= max(log_cpm), min= min(log_cpm)) %>% 
  mutate(range= max-min) %>% ungroup() %>% 
  select(ensembl_gene_id,  range) %>% distinct() %>%  
  filter(range>1.5)

pairs <- pairs[pairs$Var1 %in% genes_range1.5$ensembl_gene_id & pairs$Var2 %in% genes_range1.5$ensembl_gene_id,]

cpm_all_wide <- cpm_all_long %>% select(SampleID, ensembl_gene_id, log_cpm) %>% 
  pivot_wider(names_from = ensembl_gene_id, values_from = log_cpm) %>% column_to_rownames(var = "SampleID")

```


Method when total list of genes is too large to do all against all correlation
```{r loop genes corr res expr of selected pairs }
pairs <- pairs_GO_equal %>% 
  select(Var1, Var2) %>% 
  distinct()

#loop over pairs of interest's expression level and calculate correlations (with p-values)
#loop over pairs of interest's residual levels and calculate correlations (with p-values)
cor_subset <- cpm_all_wide[, colnames(cpm_all_wide) %in% c(pairs[,1], pairs[,2]) ]

corr_res_expr_loop = data.frame()
counter <- 0

for(i in seq(1:length(rownames(pairs)))){
  #define genes from one pair at a time
  geneX = pairs[i,1]
  geneY = pairs[i,2]

  #correlations and p-values: expression
  cor_p = cor.test(cor_subset[,geneX], cor_subset[,geneY], conf.level = 0.95)
  #correlations and p-values: residuals
  cor_res_p = cor.test(res_poly_all_df[geneX,], res_poly_all_df[geneY,], conf.level = 0.95)

  corr_res_expr_loop = rbind(corr_res_expr_loop, cbind(cor_p$estimate, cor_p$p.value, cor_res_p$estimate, cor_res_p$p.value, geneX, geneY))

  counter <- counter + 1;
                  if(counter %in% seq(0, length(rownames(pairs)), round(length(rownames(pairs))/10)))
                      print(paste(round(counter/length(rownames(pairs))*100), "% has been processed"))
  }

# 
# 
names(corr_res_expr_loop)[1] <- "corr_expr"
names(corr_res_expr_loop)[2] <- "p_expr"
names(corr_res_expr_loop)[3] <- "corr_res"
names(corr_res_expr_loop)[4] <- "p_res"
names(corr_res_expr_loop)[5] <- "geneX"
names(corr_res_expr_loop)[6] <- "geneY"

corr_res_expr <-
  as_tibble(corr_res_expr_loop) %>%
  select(geneX, geneY, corr_expr, p_expr, corr_res, p_res ) %>% 
  distinct()

#adjust p-values for multiple testing (FDR)
corr_res_expr <- adjust_pvalue(corr_res_expr, p.col = "p_res", output.col = "p_res_adj", method = "fdr")
corr_res_expr <- adjust_pvalue(corr_res_expr, p.col = "p_expr", output.col = "p_expr_adj", method = "fdr")


```


Method when total list of genes is small enough to do all against all correlation
```{r compute corr res expr for all pairs of genes}

#If n genes <2000, it is possible to get correlations from all, and afterwards pick out the ones we're interested in.

cor_subset <- cpm_all_wide[, colnames(cpm_all_wide) %in% pos_linear$ensembl_gene_id | colnames(cpm_all_wide) %in% neg_linear$ensembl_gene_id]

#set.seed(22)
#random300 <- cpm_all_wide[, sample(colnames(cpm_all_wide), 300, replace=F)]
#cor_subset <- random300

# 3. find correlation value and p for each pairs of expression
M = cor(cor_subset)
M[lower.tri(M)] <- NA #removes the reverse correlation

Mexpr = cor.mtest(cor_subset, conf.level = 0.95)
Mexpr$p[lower.tri(Mexpr$p)] <- NA #removes the reverse correlation
Mexpr_p <- as.data.frame(Mexpr$p)

# 4. find correlation value and p for each pairs of residuals
#library(corrplot)
M_res = cor(t(res_poly_all_df[rownames(res_poly_all_df) %in% colnames(cor_subset),]))
M_res[lower.tri(M_res)] <- NA #removes the reverse correlation
Mres = cor.mtest(t(res_poly_all_df[rownames(res_poly_all_df) %in% colnames(cor_subset),]), conf.level = 0.95)
Mres$p[lower.tri(Mres$p)] <- NA #removes the reverse correlation

Mres_p <- Mres$p



#corrplot(M, p.mat = Res$p, method = 'circle', type = 'lower', insig='blank',
#         order = 'AOE', diag = FALSE)$corrPos -> p1
#text(p1$x, p1$y, round(p1$corr, 2))

#combine correlations and p-values for both expression and residuals. Remove the bottom triangle of the matrices (now "NA"), i.e only include one entry per gene pair
M_expr_long <- as.data.frame(M) %>% 
  rownames_to_column(var= "geneX") %>% 
  pivot_longer(cols= -1, names_to = "geneY", values_to = "corr_expr") %>% 
  drop_na()

M_res_long <- as.data.frame(M_res) %>% 
  rownames_to_column(var= "geneX") %>% 
  pivot_longer(cols= -1, names_to = "geneY", values_to = "corr_res")  %>% 
  drop_na()

p_expr_long <- as.data.frame(Mexpr_p) %>% 
  rownames_to_column(var= "geneX") %>% 
  pivot_longer(cols= -1, names_to = "geneY", values_to = "p_expr") %>% 
  mutate(geneY= str_remove(geneY, "p.")) %>% 
  drop_na()

p_res_long <- as.data.frame(Mres_p) %>% 
  rownames_to_column(var= "geneX") %>% 
  pivot_longer(cols= -1, names_to = "geneY", values_to = "p_res") %>% 
  mutate(geneY= str_remove(geneY, "p.")) %>% 
  drop_na()


#combine all
corr_res_expr <- 
  M_expr_long %>% 
  left_join(M_res_long, join_by(geneX, geneY)) %>% 
  left_join(p_expr_long, join_by(geneX, geneY)) %>% 
  left_join(p_res_long, join_by(geneX, geneY)) %>% 
  filter(geneX != geneY) #remove self-self correlations

#adjust p-values for multiple testing (FDR)
corr_res_expr <- adjust_pvalue(corr_res_expr, p.col = "p_res", output.col = "p_res_adj", method = "fdr")
corr_res_expr <- adjust_pvalue(corr_res_expr, p.col = "p_expr", output.col = "p_expr_adj", method = "fdr")


```


Genes with opposite linear trend (and crossing expression trend lines)
```{r opposite linear }
##start here with gene pair selection 

#add gene symbol
corr_res_expr <- 
  corr_res_expr %>% 
  left_join(select(genemap, ensembl_gene_id, external_gene_name), by= c("geneX"= "ensembl_gene_id" )) %>% 
  rename("gene_name_X" = external_gene_name) %>% 
    left_join(select(genemap, ensembl_gene_id, external_gene_name), by= c("geneY"= "ensembl_gene_id" )) %>% 
  rename("gene_name_Y" = external_gene_name)

#if relevant, add both genes' linear age-coefficient and their p-value
corr_res_expr <- 
  corr_res_expr %>% 
  left_join(select(age_trend_genes_linear_adj, ensembl_gene_id, lin_coeff, p_linear_adj), by= c("geneX" = "ensembl_gene_id")) %>%
  dplyr::rename("geneX_lin_coeff" = lin_coeff, "geneX_lin_p_adj" = p_linear_adj)
  
corr_res_expr <- 
  corr_res_expr %>% 
  left_join(select(age_trend_genes_linear_adj, ensembl_gene_id, lin_coeff, p_linear_adj), by= c("geneY" = "ensembl_gene_id")) %>%
  dplyr::rename("geneY_lin_coeff" = lin_coeff, "geneY_lin_p_adj" = p_linear_adj)

#only keep gene pairs with opposite coefficients
corr_res_expr <- 
  corr_res_expr %>% 
  filter(sign(geneX_lin_coeff) != sign(geneY_lin_coeff)) 
  
#only keep genes where residuals are significantly negative (p.adj)
corr_res_expr <- 
  corr_res_expr %>% 
  filter(p_res_adj <= sig_level)

#only keep genes where both members of pair have a certain range
corr_res_expr <- 
  corr_res_expr %>% 
  filter(geneX %in% genes_range1.5$ensembl_gene_id & 
           geneY %in% genes_range1.5$ensembl_gene_id)

#IA's idea: only keep gene pairs that have their fitted line cross each other
#linear slope and intercept
linear_slope_intrcpt <- cpm_all_long %>%     
  group_by(ensembl_gene_id) %>% 
    do({
        mod = lm(log_cpm ~ AGE, data = .)
        data.frame(Intercept = coef(mod)[1],
                   Slope = coef(mod)[2])
    })

intersect <- function(intX, intY, slX, slY){   #2 lines defined by intercept and slope (geneX and geneY). https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_line_equations
    x <- (intY - intX) / (slX - slY) 
    y <- intX + slX * x
    return(xy=c(x, y)) #NA if they don't cross
}


#connect genes into pairs and have their intercepts and slopes side-by-side
corr_res_expr_intersect <- 
  corr_res_expr %>% 
  left_join(linear_slope_intrcpt, by= c("geneX" = "ensembl_gene_id")) %>% 
  dplyr::rename("Intercept_geneX"= Intercept, "Slope_geneX"= Slope)

corr_res_expr_intersect <- 
  corr_res_expr_intersect %>% 
  left_join(linear_slope_intrcpt, by= c("geneY" = "ensembl_gene_id")) %>% 
  dplyr::rename("Intercept_geneY"= Intercept, "Slope_geneY"= Slope)

intersections <- base::mapply(intersect, 
                        corr_res_expr_intersect$Intercept_geneX, 
                        corr_res_expr_intersect$Intercept_geneY,
                        corr_res_expr_intersect$Slope_geneX,
                        corr_res_expr_intersect$Slope_geneY)

corr_res_expr_intersect$intersect_x <- intersections[1,]
corr_res_expr_intersect$intersect_y <- intersections[2,]

#check to see if it intersects during range of ages
low_age <- range(cpm_all_long$AGE)[1]
high_age <- range(cpm_all_long$AGE)[2]

corr_res_expr_intersect <-
  corr_res_expr_intersect %>% 
  mutate(intersect_in_range = ifelse(between(intersect_x, low_age, high_age),
         TRUE,
         FALSE
         )) 


#visualise intersection points (age)
corr_res_expr_intersect %>% 
  filter(intersect_in_range ==TRUE) %>% 
  ggplot(aes(x= intersect_x, y=intersect_y )) +
  geom_bin_2d() +
  geom_vline(xintercept = low_age) +
  geom_vline(xintercept = high_age) 


corr_res_expr <- corr_res_expr_intersect %>% filter(intersect_in_range == TRUE)


corr_res_expr_GO_equal <- 
  corr_res_expr %>% 
  left_join(pairs_GO_equal, by= c("geneX" = "Var1", "geneY" = "Var2")) %>% 
  drop_na()

#visualise GO-terms' p-value of 



p_thr = 0.01
cor_thr = 0.5

#categorise whether significant in both expr and res
# corr_res_expr_cat <- corr_res_expr %>% 
#   mutate(cat= case_when(
#     corr_expr > 0 & corr_res > 0 & p_expr  < p_thr & p_res < p_thr  ~ "pos_expr_pos_res",
#     corr_expr < 0 & corr_res < 0 & p_expr  < p_thr & p_res < p_thr  ~ "neg_expr_neg_res",
#     corr_expr > 0 & corr_res < 0 & p_expr  < p_thr & p_res < p_thr  ~ "pos_expr_neg_res",
#     corr_expr < 0 & corr_res > 0 & p_expr  < p_thr & p_res < p_thr  ~ "neg_expr_pos_res",
#      p_expr  > p_thr & p_res > p_thr  ~ "notsign_expr_notsign_res",
#     corr_expr > 0  & p_expr  < p_thr & p_res > p_thr  ~ "pos_expr_notsign_res",
#     corr_expr < 0  & p_expr  < p_thr & p_res > p_thr  ~ "neg_expr_notsign_res",
#     corr_res > 0  & p_expr  > p_thr & p_res < p_thr  ~ "notsign_expr_pos_res",
#     corr_res < 0  & p_expr  > p_thr & p_res < p_thr  ~ "notsign_expr_neg_res",
#          )
#   )

#categorise whether significant in both expr and res: FDR-adjusted p-values
corr_res_expr_cat <- corr_res_expr %>% 
  mutate(cat= case_when(
    corr_expr > 0 & corr_res > 0 & p_expr_adj < p_thr & p_res_adj < p_thr  ~ "pos_expr_pos_res",
    corr_expr < 0 & corr_res < 0 & p_expr_adj < p_thr & p_res_adj < p_thr  ~ "neg_expr_neg_res",
    corr_expr > 0 & corr_res < 0 & p_expr_adj < p_thr & p_res_adj < p_thr  ~ "pos_expr_neg_res",
    corr_expr < 0 & corr_res > 0 & p_expr_adj < p_thr & p_res_adj < p_thr  ~ "neg_expr_pos_res",
     p_expr_adj > p_thr & p_res_adj > p_thr  ~ "notsign_expr_notsign_res",
    corr_expr > 0  & p_expr_adj < p_thr & p_res_adj > p_thr  ~ "pos_expr_notsign_res",
    corr_expr < 0  & p_expr_adj < p_thr & p_res_adj > p_thr  ~ "neg_expr_notsign_res",
    corr_res > 0  & p_expr_adj > p_thr & p_res_adj < p_thr  ~ "notsign_expr_pos_res",
    corr_res < 0  & p_expr_adj > p_thr & p_res_adj < p_thr  ~ "notsign_expr_neg_res",
         )
  )

#order the categories

corr_res_expr_cat$cat <- factor(corr_res_expr_cat$cat, 
                                levels = c("neg_expr_pos_res", "notsign_expr_pos_res", "pos_expr_pos_res",
                                           "neg_expr_notsign_res", "notsign_expr_notsign_res",  "pos_expr_notsign_res",
                                           "neg_expr_neg_res", "notsign_expr_neg_res", "pos_expr_neg_res" ))

#Create count data for labels
Labels <- corr_res_expr_cat %>% group_by(cat, .drop=FALSE) %>% summarise(N=paste0('n: ',n(), ",\n", round(digits = 3, n()/length(corr_res_expr_cat$geneX))*100, "%"))
#X position
Labels$corr_expr <- 0.5


#max freqpoly in order to place percentage correctly in plot
#find largest category
max_cat <- corr_res_expr_cat %>% group_by(cat) %>% count() %>% ungroup() %>%  slice_max(n=1, order_by = n) %>% select(cat)
max_n <- max(hist(corr_res_expr_cat$corr_expr[corr_res_expr_cat$cat == max_cat$cat], plot=FALSE)$counts)



#visualise 
  cat_count <- corr_res_expr_cat %>% 
  pivot_longer(cols= c(corr_expr, corr_res), names_to = "cor_source", values_to = "cor") %>% 
  ggplot(aes(x=corr_expr, 
             stat = "count",fill=as.factor(cat))) + 
  geom_freqpoly(aes(x= cor, colour= cor_source, linetype= cor_source)) +
  geom_text(data = Labels, aes(x=corr_expr,
                               y=max_n,
                               label=N)) +
  facet_wrap(~cat, nrow = 3, ncol = 3, drop = FALSE)  +
  scale_colour_manual(values = c(corr_expr= "black", corr_res="blue") )+
  scale_linetype_manual(values  = c(corr_expr= 1, corr_res= 2)) +
  theme(text = 
        element_text(size=10) ) +
  ylab("count: gene pairs")
  
#2D plot of the 2 correlation measures' p-values
#transform p-value on a log scale, sign according to positive or negative correlation
corr_res_expr_cat <- corr_res_expr_cat %>% 
  mutate(log_p_expr_cor= -log(p_expr) * sign(corr_expr )) %>% 
  mutate(log_p_res_cor= -log(p_res) * sign(corr_res ))

heatColours <- c("darkblue", "blue", "cyan", "red", "orange", "gold", "yellow" )

corr_res_expr_cat %>% 
ggplot() + 
  geom_bin2d(aes(log_p_expr_cor, log_p_res_cor), binwidth= c(1,1)) +
  scale_fill_gradientn(
    colours = heatColours, trans="log10"
    ) #+
  facet_wrap(~cat, nrow = 3, ncol = 3, drop = FALSE)
  

#corr_res_expr_cat %>% 
#  pivot_longer(cols= c(corr_expr, corr_res), names_to = "cor_source", values_to = "cor") 
c <- "neg_expr_neg_res"
  
plotlist <- list()

for(c in c("neg_expr_neg_res", "pos_expr_pos_res", "neg_expr_notsign_res", "neg_expr_notsign_res", "notsign_expr_neg_res")){

corr_res_expr_vis <- 
  corr_res_expr_cat %>%  
 filter(cat==c) %>% 
  filter(geneX %in% age_trend_genes$ensembl_gene_id & 
           geneY %in% age_trend_genes$ensembl_gene_id) %>% 
  pivot_longer(cols = c(gene_name_X, gene_name_Y), names_to = "pair_member", values_to = "gene_name") %>% #one gene per row
  group_by(gene_name) %>% 
  slice_min(p_res_adj, n=1, with_ties = FALSE) %>% #make sure no gene is in more than one pair for plotting
    ungroup() %>% 
    pivot_wider( names_from = pair_member, values_from = gene_name) %>%
  arrange(p_res_adj) %>%  
  drop_na() 

  if (nrow(corr_res_expr_vis) == 0) next  #skip category if there is no examples

#visualise examples
  #visualise gene expression of negatively correlated pairs
 visualise_expr <-  cpm_all_long %>% 
     mutate(pair = case_when(
    ensembl_gene_id  %in% corr_res_expr_vis[1, 1:2] ~ "1",
    ensembl_gene_id  %in% corr_res_expr_vis[2, 1:2] ~ "2",
    ensembl_gene_id  %in% corr_res_expr_vis[3, 1:2] ~ "3",
    ensembl_gene_id  %in% corr_res_expr_vis[4, 1:2] ~ "4",
    TRUE ~ NA)) %>% 
    drop_na

 #define correct label order
vis_genes <- visualise_expr %>% 
  arrange(pair) %>% 
  select(gene_id, pair) %>%  
  distinct() %>% select(gene_id)   

vis_genes <- factor(vis_genes$gene_id, levels = vis_genes$gene_id)

#add in p-value of the coefficient on the linear age variable 
 visualise_expr <-
 visualise_expr %>% 
   left_join(select(poly_coeff_pvalue_df, `poly(AGE, 2)1`, ensembl_gene_id), by="ensembl_gene_id")
 
#plot
  plot <- visualise_expr %>% 
    ggplot(aes(x=AGE, y= log_cpm, colour=gene_id)) +
  geom_point()+ 
    facet_wrap(~pair, scales = "free_y") +
  geom_smooth(method = lm, formula = y ~ poly(x, 2), se = FALSE) +
        scale_colour_brewer(breaks= vis_genes, palette = "Dark2" ) +
   #       geom_dl(label=paste(as.factor(visualise_expr$gene_id), ",", " lin_coeff_p =", signif(visualise_expr$`poly(AGE, 2)1`, digits=3), sep = ""), method="smart.grid", inherit.aes=T) +
    labs( title=c)
 
plotlist[[c]] <- plot    
}   
   
plot(ggarrange(plotlist = plotlist)  )

combined_plot <-   ggarrange(plotlist = plotlist)

plot_neg_cor <- plotlist$neg_expr_neg_res

ggsave(combined_plot, file = paste0(res_dir, "expression_examples_categories.pdf"))     
ggsave(plot_neg_cor, file = paste0(res_dir, "plot_expr_neg_cor.pdf"))     
ggsave(cat_count, file = paste0(res_dir, "cat_count.pdf"))    
#save correlation values   
write_tsv(corr_res_expr_cat, file = paste0(res_dir, "corr_res_expr_cat.txt"))

#write.csv(corr_res_expr_cat, file = paste0(res_dir, "corr_res_expr_cat.txt"), sep  = "\t")
```

```{r GOterms when both genes in pairs have the same}



#visualise examples
#visualise gene expression of negatively correlated pairs
visualise_expr <-  cpm_all_long %>%
mutate(pair = case_when(
ensembl_gene_id  %in% corr_res_expr_vis[1, 1:2] ~ "1",
ensembl_gene_id  %in% corr_res_expr_vis[2, 1:2] ~ "2",
ensembl_gene_id  %in% corr_res_expr_vis[3, 1:2] ~ "3",
ensembl_gene_id  %in% corr_res_expr_vis[4, 1:2] ~ "4",
TRUE ~ NA)) %>%
drop_na()

#define correct label order
vis_genes <- visualise_expr %>%
  arrange(pair) %>%
  select(gene_id, pair) %>%
  distinct() %>% select(gene_id)
  
vis_genes <- factor(vis_genes$gene_id, levels = vis_genes$gene_id)

#add in p-value of the coefficient on the linear age variable
visualise_expr <-
  visualise_expr %>%
  left_join(select(poly_coeff_pvalue_df, `poly(AGE, 2)1`, ensembl_gene_id), by="ensembl_gene_id")

#plot
plot <- 
  visualise_expr %>%
  ggplot(aes(x=AGE, y= log_cpm, colour=gene_id)) +
  geom_point()+
  facet_wrap(~pair, scales = "free_y") +
  geom_smooth(method = lm, formula = y ~ poly(x, 2), se = FALSE) +
  scale_colour_brewer(breaks= vis_genes, palette = "Dark2" ) +


corr_res_expr_vis %>%   
  distinct() %>% head(n=4) %>% 
  left_join(select(pairs_GO_equal, Var1, Var2, GO, Term), by = c("geneX" = "Var1", "geneY" = "Var2")) %>%    select(21:24)

```


```{r correlation residuals and expression in paralog pairs}
#filter out paralog gene pairs. Not only GO: neuro!

corr_res_expr_paralog1 <-   
  corr_res_expr %>% 
  inner_join(
    select(paralogs, 
           ensembl_gene_id, hsapiens_paralog_ensembl_gene, hsapiens_paralog_perc_id), 
             by = c("geneX"="ensembl_gene_id", "geneY"="hsapiens_paralog_ensembl_gene"))  %>% 
  distinct()
   
corr_res_expr_paralog2 <-   
  corr_res_expr %>% 
  inner_join(
    select(paralogs, 
           ensembl_gene_id, hsapiens_paralog_ensembl_gene, hsapiens_paralog_perc_id), 
             by = c("geneY"="ensembl_gene_id", "geneX"="hsapiens_paralog_ensembl_gene")) %>% 
  distinct()

corr_res_expr_paralog <- bind_rows(corr_res_expr_paralog1, corr_res_expr_paralog2) %>%  distinct()
 

p_thr = 0.01
cor_thr = 0.5

#categorise whether significant in both expr and res
corr_res_expr_paralog_cat <- corr_res_expr_paralog %>% 
  mutate(cat= case_when(
    corr_expr > 0 & corr_res > 0 & p_expr  < p_thr & p_res < p_thr  ~ "pos_expr_pos_res",
    corr_expr < 0 & corr_res < 0 & p_expr  < p_thr & p_res < p_thr  ~ "neg_expr_neg_res",
    corr_expr > 0 & corr_res < 0 & p_expr  < p_thr & p_res < p_thr  ~ "pos_expr_neg_res",
    corr_expr < 0 & corr_res > 0 & p_expr  < p_thr & p_res < p_thr  ~ "neg_expr_pos_res",
     p_expr  > p_thr & p_res > p_thr  ~ "notsign_expr_notsign_res",
    corr_expr > 0  & p_expr  < p_thr & p_res > p_thr  ~ "pos_expr_notsign_res",
    corr_expr < 0  & p_expr  < p_thr & p_res > p_thr  ~ "neg_expr_notsign_res",
    corr_res > 0  & p_expr  > p_thr & p_res < p_thr  ~ "notsign_expr_pos_res",
    corr_res < 0  & p_expr  > p_thr & p_res < p_thr  ~ "notsign_expr_neg_res",
         )
  )

#order the categories
corr_res_expr_paralog_cat$cat <- factor(corr_res_expr_paralog_cat$cat, levels = c("neg_expr_neg_res", "notsign_expr_neg_res", "pos_expr_neg_res",
                                                      "neg_expr_notsign_res", "notsign_expr_notsign_res", "pos_expr_notsign_res",
                                                      "neg_expr_pos_res", "notsign_expr_pos_res", "pos_expr_pos_res"))


#Create count data for labels
Labels <- corr_res_expr_paralog_cat %>% group_by(cat, .drop=FALSE) %>% summarise(N=paste0('n: ',n(), ",\n", round(digits = 3, n()/length(corr_res_expr_paralog_cat$geneX))*100, "%"))
#X position
Labels$corr_expr <- 0.5




#visualise 
corr_res_expr_paralog_cat %>% 
  pivot_longer(cols= c(corr_expr, corr_res), names_to = "cor_source", values_to = "cor") %>% 
  ggplot(aes(x=corr_expr, 
             stat = "count",fill=as.factor(cat))) + 
  geom_freqpoly(aes(x= cor, colour= cor_source, linetype= cor_source)) +
  geom_text(data = Labels, aes(x=corr_expr,y=40,label=N)) +
  facet_wrap(~cat, nrow = 3, ncol = 3, drop = FALSE)  +
  scale_colour_manual(values = c(corr_expr= "black", corr_res="blue") )+
  scale_linetype_manual(values  = c(corr_expr= 1, corr_res= 2)) +
  theme(text = 
        element_text(size=10) ) +
  ylab("count: gene pairs")
  
###Negative correlation


#negative correlation
neg_corr_res_expr_paralog <- 
  corr_res_expr_paralog_cat %>%  
  filter(cat== "neg_expr_neg_res") %>% 
  filter(geneX %in% age_trend_genes$ensembl_gene_id & geneY %in% age_trend_genes$ensembl_gene_id) %>% 
  dplyr::group_by(gene_name_X, gene_name_Y) %>% 
  dplyr::slice(which.max(hsapiens_paralog_perc_id)) %>%  #need to have this, as there are multiple entries for homology percentage
  ungroup() %>% 
  arrange(p_res) 

#visualise examples
  #visualise gene expression of negatively correlated pairs
 visualise_expr <-  cpm_all_long %>% 
     mutate(pair = case_when(
    ensembl_gene_id  %in% neg_corr_res_expr_paralog[1, 1:2] ~ "1",
    ensembl_gene_id  %in% neg_corr_res_expr_paralog[2, 1:2] ~ "2",
    ensembl_gene_id  %in% neg_corr_res_expr_paralog[3, 1:2] ~ "3",
    ensembl_gene_id  %in% neg_corr_res_expr_paralog[4, 1:2] ~ "4",
    TRUE ~ NA)) %>% 
    drop_na

 #define correct label order
vis_genes <- visualise_expr %>% arrange(pair) %>% select(gene_id, pair) %>%  distinct() %>% select(gene_id)   
vis_genes <- factor(vis_genes$gene_id, levels = vis_genes$gene_id)

#plot
   visualise_expr %>% 
   #  left_join(select(corr_res_expr_paralog_cat,corr_expr, corr_res, gene_name_X, gene_name_Y, p_res_adj, p_expr_adj), by= c("gene_id"= "gene_name_X")) %>% head()
    ggplot(aes(x=AGE, y= log_cpm, colour=gene_id)) +
  geom_point()+ 
    facet_wrap(~pair, scales = "free_y") +
  geom_smooth(method = lm, formula = y ~ poly(x, 2), se = FALSE) +
        scale_colour_brewer(breaks= vis_genes, palette = "Dark2" ) +
     geom_dl(label=as.factor(visualise_expr$gene_id), method="last.qp", inherit.aes=T) + 
    labs( title="Negatively correlated gene pairs: expression and residuals") 
   
    
   
   ###positive correlation    
    
    
  #visualise gene expression of positively correlated pairs
pos_corr_res_expr_paralog <- 
  corr_res_expr_paralog_cat %>%  
  filter(cat== "pos_expr_pos_res") %>%
  dplyr::group_by(gene_name_X, gene_name_Y) %>% 
  dplyr::slice(which.max(hsapiens_paralog_perc_id)) %>%  #need to have this, as there are multiple entries for homology percentage
  ungroup() %>% 
  arrange(p_res) %>%  
  head(n=4) %>% 
  mutate(pair= as.character(1:n())) 
  

#visualise examples
  #visualise gene expression of positively correlated pairs
 visualise_expr <-  cpm_all_long %>% 
     mutate(pair = case_when(
    ensembl_gene_id  %in% pos_corr_res_expr_paralog[1, 1:2] ~ "1",
    ensembl_gene_id  %in% pos_corr_res_expr_paralog[2, 1:2] ~ "2",
    ensembl_gene_id  %in% pos_corr_res_expr_paralog[3, 1:2] ~ "3",
    ensembl_gene_id  %in% pos_corr_res_expr_paralog[4, 1:2] ~ "4",
    TRUE ~ NA)) %>% 
    drop_na

#add in correlation values for plotting
 visualise_expr <-
 visualise_expr %>% 
   left_join(select(pos_corr_res_expr_paralog, corr_expr, corr_res, p_res_adj, p_expr_adj, hsapiens_paralog_perc_id, pair), by="pair") 
 
#add in p-value of the coefficient on the linear age variable 
 visualise_expr <-
 visualise_expr %>% 
   left_join(select(poly_coeff_pvalue_df, `poly(AGE, 2)1`, ensembl_gene_id), by="ensembl_gene_id")
 
  #define correct label order
vis_genes <- visualise_expr %>% arrange(pair) %>% select(gene_id, pair) %>%  distinct() %>% select(gene_id)   
vis_genes <- factor(vis_genes$gene_id, levels = vis_genes$gene_id)

# Data frame with y-position of labels. I've set the value to 90% of the maximum 
# value of log_cpm
pos = visualise_expr %>% group_by(pair) %>%
  summarise(y.pos = 0.9 * max(log_cpm))


#plot
   visualise_expr %>% 
     left_join(pos, by= "pair") %>%  #add in y-position for text labels in plot
    ggplot(aes(x=AGE, y= log_cpm, colour=gene_id)) +
  geom_point()+ 
    facet_wrap(~pair, scales = "free_y") +
  geom_smooth(method = lm, formula = y ~ poly(x, 2), se = FALSE) +
        scale_colour_brewer(breaks= vis_genes, palette = "Dark2" ) +
     geom_dl(label=paste(as.factor(visualise_expr$gene_id), ",", " coeff_p =", signif(visualise_expr$`poly(AGE, 2)1`, digits=3), sep = ""), method="smart.grid", inherit.aes=T) + 
    labs( title="Positively correlated gene pairs: expression and residuals") +
     geom_text(mapping= aes(
       label = paste("res_corr:", 
                     round(corr_res, digits = 3), "p=", signif(p_res_adj, digits=3), sep = " "), 
       x= 15, y= y.pos), 
       colour= "black" ) 
   
```




```{r enrichment analysis}
library(org.Hs.eg.db)
library(clusterProfiler)
library(enrichplot)
library(DOSE)
library(rrvgo) # Reduce + Visualize GO by identifying redundance based on semantic similarity.


 
#BP: Biological Process 
#CC: Cellular Component 
#MF: Molecular Function

# below vs above 12 years-old, OFC
gene <- rownames(DE_0.01_OFC[res$adj.P.Val < 0.01,])
# below vs above 12 years-old, CC

#OFC vs CC
res <- res_region
gene <- rownames(res[res$adj.P.Val < 0.01,])

#OFC higher than CC
analysis <- "higherOFC"
res_dir <- "~/proj_Maryland_WGCNA/analysis/OFC_CC_DE/highOFC/"
res <- res_region
gene <- high_OFC_FDR_001$ensembl_gene_id

#CC higher than OFC
analysis <- "higherCC"
res_dir <- "~/proj_Maryland_WGCNA/analysis/OFC_CC_DE/highCC/"
res <- res_region
gene <- low_OFC_FDR_001$ensembl_gene_id

#Genes with significant age-coefficient
gene <- age_trend_genes_linear$ensembl_gene_id
 analysis <- "age_trend_genes_OFC"
 #analysis <- "age_trend_genes_CC"
res_dir <- paste0("~/proj_Maryland_WGCNA/analysis/", analysis, "/")

#gene <- rownames(res[res$adj.P.Val < 0.05,])

#negatively correlated gene pairs with age trend
neg_corr_gene_pairs <- 
  corr_res_expr_cat %>% 
  filter(cat == "neg_expr_neg_res") %>% 
  select(geneX, geneY) 

gene <- unique(genemap2$ensembl_gene_id[genemap2$ensembl_gene_id %in% neg_corr_gene_pairs$geneX | genemap2$ensembl_gene_id %in% neg_corr_gene_pairs$geneY])



#GO over-representation analysis
ego <- enrichGO(gene          = gene,
                #universe      = rownames(res), 
                 universe      = age_trend_genes_linear_adj$ensembl_gene_id, 
                #poly_coeff_pvalue_df$ensembl_gene_id,
                keyType = "ENSEMBL",
                OrgDb         = org.Hs.eg.db,
                ont           = "BP",
                pAdjustMethod = "fdr",
                pvalueCutoff  = 0.1,
                qvalueCutoff  = 0.1,
        readable      = TRUE)

  head(ego@result)

  dotplot(ego, showCategory=30)
 GO_dotplot <- dotplot(ego, showCategory=30, )

 
#method to group GO-terms into simpler result 
ego_simple <- clusterProfiler::simplify(
  ego,
  cutoff = 0.7,
  by = "p.adjust",
  select_fun = min,
  measure = "Wang",
  semData = NULL
  )

clusterProfiler::dotplot(ego_simple, showCategory=30)


#reduce GO-terms by adding the parent term
#convert to dataframe and score GO-terms
  simMatrix <- calculateSimMatrix(ego$ID, orgdb="org.Hs.eg.db", ont="BP", method="Rel")
  scores <- setNames(-log10(ego$p.adjust), ego$ID)
  red <- reduceSimMatrix(simMatrix, scores, threshold=0.7, orgdb="org.Hs.eg.db")

#merge parentTerms with the original GO-result 
  ego_red_df <- merge(base::as.data.frame(ego), base::as.data.frame(red), by=0)

#find the most significant member of a parentTerm  
  ego_red_sign <- ego_red_df  %>% 
    filter( p.adjust < 0.1) %>% 
    arrange(p.adjust) %>%  
    group_by(parentTerm) %>% 
    dplyr::mutate(sum_size= sum(size)) %>%  
    slice_min(p.adjust)

#count genes per parentTerm
 count_genes_parentTermGO <-  
   ego_red_df %>% 
    separate_wider_delim(cols = geneID, 
                         delim= "/", 
                         names_sep = "", 
                         too_few = "align_start") %>% 
    pivot_longer(cols = starts_with("geneID"), 
                 names_to = "geneID_place", 
                 values_to = "geneID") %>% 
    select(parentTerm, geneID) %>%  
    drop_na(geneID) %>% distinct()  %>% 
    dplyr::group_by(parentTerm) %>% count(parentTerm) %>% arrange(desc(n))

#count total unique genes associated with a parentTerm
total_genes_parentTerm <- ego_red_df %>% 
  separate_wider_delim(cols = geneID, delim= "/", names_sep = "", too_few = "align_start") %>%
  pivot_longer(cols = starts_with("geneID"), names_to = "geneID_place", values_to = "geneID") %>%
  select(parentTerm, geneID) %>%  
  drop_na(geneID) %>% 
  select(geneID) %>% distinct() %>%  
  nrow()  

#insert total unique gene count per parentTerm
#actually, GeneRatio is ususally the percentage of total genes of interest in the given GO term 
ego_red_sign_total <-
  ego_red_sign %>% 
  left_join(count_genes_parentTermGO, by= "parentTerm")

totalGenes <- length(unique(gene))

#plot enriched GO parent terms  
  parentGO_plot <- 
    ggplot(ego_red_sign_total, 
         aes(x=n/totalGenes, y=reorder(parentTerm, n, FUN=mean))
         ) + 
    geom_point(aes(colour= p.adjust, size= n)) + 
    viridis::scale_color_viridis() +
    theme(axis.text = element_text(size=8)) +
    labs(colour= "min. p.adjust", 
         x= "GeneRatio: genes in GO parent term/ total genes of interest in GO-terms",
         y= "GO parentTerm"
         )
  
 ggsave(parentGO_plot, file = paste0(res_dir, "/plot_reducedGOenrich.pdf" ),
        #height = length(ego_red_sign$ID)/3, 
        height= 12,
        width= 18, units = "cm")  
  
 ggsave(GO_dotplot, file = paste0(res_dir, "/plot_GOenrich.pdf" ))  
   
  ggsave(GO_dotplot, file = paste0(res_dir, "/plot_GOenrich.pdf"),
         height= 30,
         width= 18, units = "cm" )  
  

 
 
```

```{r gene set enrichment of ranked linear coefficients }
#analysis <- "age_trend_genes_CC/ranked_linear"

analysis <- "age_trend_genes_OFC/ranked_linear"
age_trend_genes_linear_adj <- read_tsv( file ="~/proj_Maryland_WGCNA/analysis/age_trend_genes_OFC/age_trend_linear.txt"  )

res_dir <- paste0("~/proj_Maryland_WGCNA/analysis/", analysis, "/")

#metod using ranked gene lists. But can't input universe (all relevant genes)? IA: ok to include all genes in database.
 linear_nom <- 
  age_trend_genes_linear_adj %>% 
  filter(p< sig_level)

 
geneList <- c(
 # abs(
    linear_nom$lin_coeff)
 # ) #Do not use absolute if you want to separate negative from positive trend (i.e. scoreType= "std") 
#Experiance: When absolute(lin_coeff) and "scoreType= "pos"" is used, we get no significant enrichment

names(geneList) <- linear_nom$ensembl_gene_id
geneList <- sort(geneList, decreasing =T)

gse <- gseGO(
  geneList = geneList,
  ont = "BP",
  OrgDb = org.Hs.eg.db,
  keyType = "ENSEMBL",
  exponent = 1,
  minGSSize = 10,
  maxGSSize = 500,
  eps = 1e-10,
  pvalueCutoff = 0.1,
  pAdjustMethod = "BH", scoreType= "std",
  verbose = TRUE,
  by = "fgsea"
  )
#The geneRatio in gseGO results is calculated by dotplot. The calculation method is :
#(count of core enrichment genes) / (count of pathway genes) . https://github.com/YuLab-SMU/clusterProfiler/issues/364
#-> so, this is different from the GeneRatio that is calculated in the enrichGO-method

dotplot(gse, showCategory=30)
GO_dotplot <- dotplot(gse, showCategory=30 )
 
#reduce GO-terms by adding the parent term
#convert to dataframe and score GO-terms
  simMatrix <- calculateSimMatrix(gse$ID, orgdb="org.Hs.eg.db", ont="BP", method="Rel")
  scores <- setNames(-log10(gse$p.adjust), gse$ID)
  red <- reduceSimMatrix(simMatrix, scores, threshold=0.7, orgdb="org.Hs.eg.db")

#merge parentTerms with the original GO-result 
  gse_red_df <- merge(base::as.data.frame(gse@result), base::as.data.frame(red), by=0)

#find the most significant member of a parentTerm  
  gse_red_sign <- gse_red_df  %>% 
    filter( p.adjust < 0.1) %>% 
    arrange(p.adjust) %>%  
    group_by(parentTerm) %>% 
    dplyr::mutate(sum_size= sum(size)) %>%  
    slice_min(p.adjust)

#count genes per parentTerm
 count_genes_parentTermGO <-  
   gse_red_df %>% 
    separate_wider_delim(cols = core_enrichment, 
                         delim= "/", 
                         names_sep = "", 
                         too_few = "align_start") %>% 
    pivot_longer(cols = starts_with("core_enrichment"), 
                 names_to = "geneID_place", 
                 values_to = "geneID") %>% 
    select(parentTerm, geneID) %>%  
    drop_na(geneID) %>% distinct()  %>% 
    dplyr::group_by(parentTerm) %>% count(parentTerm) %>% arrange(desc(n))

#count total unique genes associated with a parentTerm
total_genes_parentTerm <- gse_red_df %>% 
  separate_wider_delim(cols = core_enrichment, delim= "/", names_sep = "", too_few = "align_start") %>%
  pivot_longer(cols = starts_with("core_enrichment"), names_to = "geneID_place", values_to = "geneID") %>%
  select(parentTerm, geneID) %>%  
  drop_na(geneID) %>% 
  select(geneID) %>% distinct() %>%  
  nrow()  

#insert total unique gene count per parentTerm
#actually, GeneRatio is ususally the percentage of total genes of interest in the given GO term 
gse_red_sign_total <-
  gse_red_sign %>% 
  left_join(count_genes_parentTermGO, by= "parentTerm")

totalGenes <- length(unique(gene))

#plot enriched GO parent terms  
  parentGO_plot <- 
    ggplot(gse_red_sign_total, 
         aes(x=n/totalGenes, y=reorder(parentTerm, n, FUN=mean))
         ) + 
    geom_point(aes(colour= p.adjust, size= n)) + 
    viridis::scale_color_viridis() +
    theme(axis.text = element_text(size=8)) +
    labs(colour= "min. p.adjust", 
         x= "GeneRatio: genes in GO parent term/ total genes of interest in GO-terms",
         y= "GO parentTerm"
         )
  
 ggsave(parentGO_plot, file = paste0(res_dir, "/plot_parentGOenrich.pdf" ),
        #height = length(gse_red_sign$ID)/3, 
        height= 12,
        width= 18, units = "cm")  
  
 ggsave(GO_dotplot, file = paste0(res_dir, "/plot_GOenrich.pdf" ))  
 
 write_tsv(gse_red_sign_total, file = paste0(res_dir, "gse_parent_linear_coeff.txt"))

```



```{r GWAS overlap BD}
BD_GWAS_100kb <- read_tsv("~/PhD/GWAS-BD/PGC3/PGC3_loci_genes_100kb.txt")
BD_GWAS_snp_pos <- read_tsv("~/PhD/GWAS-BD/PGC3/PGC3_loci_GRCh38.txt")

BD_GWAS_l2g <- readxl::read_xlsx("~/PhD/RNAseq_temporal/paper/figures/table/genes_l2g_all_locus.xlsx")
BD_GWAS_l2g <- BD_GWAS_l2g %>%  filter(l2g >= 0.5)

BD_GWAS_100kb <- BD_GWAS_100kb %>% left_join(select(BD_GWAS_snp_pos, "Variant name", "Chromosome/scaffold position start (bp)" ), by= c("SNP" = "Variant name"))

#genes with linear age trend within 100kb from GWAS loci CC 
age_trend_genes_linear_GWAS_CC <-   
  BD_GWAS_100kb %>% 
  filter(ensgene %in% age_trend_genes_linear_adj_CC$ensembl_gene_id ) %>% 
  rowwise() %>% 
  mutate(lead_SNP_distance = min(abs(`Chromosome/scaffold position start (bp)` - `Gene start (bp)`), abs( `Chromosome/scaffold position start (bp)` - `Gene end (bp)`) )) %>% select(ensgene, symbol, Locus, SNP, CHR, lead_SNP_distance)

#genes with linear age trend within GWAS loci CC, l2g>= 0.5
age_trend_genes_linear_GWAS_l2g_CC <-   
  BD_GWAS_100kb %>% 
  filter(ensgene %in% age_trend_genes_linear_adj_CC$ensembl_gene_id ) %>% 
  filter(ensgene %in% BD_GWAS_l2g$gene_id ) %>% 
  rowwise() %>% 
  mutate(lead_SNP_distance = min(abs(`Chromosome/scaffold position start (bp)` - `Gene start (bp)`), abs( `Chromosome/scaffold position start (bp)` - `Gene end (bp)`) )) %>% select(ensgene, symbol, Locus, SNP, CHR, lead_SNP_distance)


#visualise expression when nearest gene has age trend: CC
expr_age_GWAS_closest_CC <- 
  cpm_all_long_CC %>% 
  filter(gene_id %in% age_trend_genes_linear_GWAS_CC$symbol) %>% 
  left_join(age_trend_genes_linear_GWAS_CC, by= c("gene_id" = "symbol")) %>% filter(gene_id== Nearest_gene) %>%  
  ggplot(aes(x=AGE, y= log_cpm, colour=gene_id)) +
    geom_point() + 
    facet_wrap(~gene_id, scales = "free_y") +
    geom_smooth(method = lm, formula = y ~ poly(x, 2), se = FALSE) 

#visualise expression when l2g-gene has age trend: CC
expr_age_GWAS_l2g_CC <- 
  cpm_all_long_CC %>% 
  filter(gene_id %in% age_trend_genes_linear_GWAS_l2g_CC$symbol) %>% 
  left_join(age_trend_genes_linear_GWAS_CC, by= c("gene_id" = "symbol")) %>% filter(gene_id== Nearest_gene) %>%  
  ggplot(aes(x=AGE, y= log_cpm, colour=gene_id)) +
    geom_point() + 
    facet_wrap(~gene_id, scales = "free_y") +
    geom_smooth(method = lm, formula = y ~ poly(x, 2), se = FALSE) 

#genes with linear age trend within 100kb from GWAS loci OFC
age_trend_genes_linear_adj_OFC <- read_tsv("~/proj_Maryland_WGCNA/analysis/age_trend_genes/age_trend_linear.txt")

age_trend_genes_linear_GWAS_OFC <-   
  BD_GWAS_100kb %>% 
  filter(ensgene %in% age_trend_genes_linear_adj_OFC$ensembl_gene_id ) %>% 
  rowwise() %>% 
  mutate(lead_SNP_distance = min(abs(`Chromosome/scaffold position start (bp)` - `Gene start (bp)`), abs( `Chromosome/scaffold position start (bp)` - `Gene end (bp)`) )) %>% select(ensgene, symbol, Locus, SNP, CHR, lead_SNP_distance, Nearest_gene)


#visualise expression when nearest gene has age trend: OFC
 expr_age_GWAS_closest_OFC <-
   cpm_all_long_OFC %>% filter(gene_id %in% age_trend_genes_linear_GWAS_OFC$symbol) %>% left_join(age_trend_genes_linear_GWAS_OFC, by= c("gene_id" = "symbol")) %>% filter(gene_id== Nearest_gene) %>%  ggplot(aes(x=AGE, y= log_cpm, colour=gene_id)) +
    geom_point()+ 
    facet_wrap(~gene_id, scales = "free_y") +
    geom_smooth(method = lm, formula = y ~ poly(x, 2), se = FALSE) 
 
 
#visualise expression when l2g-gene has age trend: OFC
expr_age_GWAS_l2g_OFC <- 
  cpm_all_long_OFC %>% 
  filter(gene_id %in% BD_GWAS_l2g$symbol) %>% 
  left_join(age_trend_genes_linear_GWAS_OFC, by= c("gene_id" = "symbol")) %>% filter(gene_id== Nearest_gene) %>%  
  ggplot(aes(x=AGE, y= log_cpm, colour=gene_id)) +
    geom_point() + 
    facet_wrap(~gene_id, scales = "free_y") +
    geom_smooth(method = lm, formula = y ~ poly(x, 2), se = FALSE) 
 

 
#genes in age-switch gene pair within 100kb from GWAS loci OFC 


 
 #save results
 ggsave(plot = expr_age_GWAS_closest_CC, filename = "~/proj_Maryland_WGCNA/analysis/age_trend_genes_CC/expr_age_GWAS_closest_CC.pdf")
  ggsave(plot = expr_age_GWAS_closest_OFC, filename = "~/proj_Maryland_WGCNA/analysis/age_trend_genes/expr_age_GWAS_closest_OFC.pdf")

ggsave(plot = expr_age_GWAS_l2g_CC, 
          filename = "~/proj_Maryland_WGCNA/analysis/age_trend_genes_CC/expr_age_GWAS_l2g_CC.pdf")
 
ggsave(plot = expr_age_GWAS_l2g_OFC, 
         filename = "~/proj_Maryland_WGCNA/analysis/age_trend_genes/expr_age_GWAS_l2g_OFC.pdf")
  
  
  
  
```

```{r GWAS overlap SCZ}
SCZ_GWAS_100kb <- read_tsv("~/PhD/RNAseq_temporal/genes_of_interest/SCZ_genes_biomart.txt")



```


```{r myelination genes}
myelin_genes <- readxl::read_xlsx("~/PhD/RNAseq_temporal/genes_of_interest/stokowy_steen_myelin_curated_for_r.xlsx", 
                                  sheet = "SupplementaryFile1_170306.txt")


expr_age_GWAS_myelin_CC <- 
  cpm_all_long_CC %>% 
  filter(gene_id %in% age_trend_genes_linear_GWAS_CC$symbol) %>% 
  filter(ensembl_gene_id %in% myelin_genes$`ENSEMBL ID`) %>% 
  ggplot(aes(x=AGE, y= log_cpm, colour=gene_id)) +
    geom_point() + 
    facet_wrap(~gene_id, scales = "free_y") +
    geom_smooth(method = lm, formula = y ~ poly(x, 2), se = FALSE) 


expr_age_GWAS_myelin_OFC <- 
  cpm_all_long_OFC %>% 
  filter(gene_id %in% age_trend_genes_linear_GWAS_OFC$symbol) %>% 
  filter(ensembl_gene_id %in% myelin_genes$`ENSEMBL ID`) %>% 
  ggplot(aes(x=AGE, y= log_cpm, colour=gene_id)) +
    geom_point() + 
    facet_wrap(~gene_id, scales = "free_y") +
    geom_smooth(method = lm, formula = y ~ poly(x, 2), se = FALSE) 
```

Questions:
X Higher variance in <12? 
-> Could we find examples of genes with higher variance below 12?

X Find pairs of switches (channel subunits etc). Plot their expression with age.
X Especially at paralog pairs. 
-> High/ low homology.

X 2D density plot res_cor, expr_cor p-value (see mail)

X Add res corr- and p-value to gene pair expr plot. 
X  Also p of the coefficient on the linear age variable?

(x) Enrichment analysis with ClusterProfiler (remember to combine into fewer pathways)
Enrichment for myelin-related genes in CC?

DE genes overlap with BD/SCZ GWAS? Switches overlapping? Distance to nearest locus/ overlap with gene list within pre-defined genomic window around loci?
 
 
X "DE-analysis" alternative: test whether the coefficient on the linear age variable  (the one to the power of 1) in the fitted line is significantly different from 0.
 X code to get significant genes, nominally and FDR, linear/ all coefficients 

X Plot some of the extreme examples of not-significant/significant in correlation
X Filter on age-function coefficients to find age trends

